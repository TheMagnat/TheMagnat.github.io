[{"content":"Introduction Cet article est un devlog parlant de l\u0026rsquo;impl√©mentation d\u0026rsquo;un syst√®me de collision pour mon moteur de voxels Mavoxel üòâ.\nLe principe d\u0026rsquo;une collision est assez simple : si une entit√© est en mouvement, on va s\u0026rsquo;assurer que la position d\u0026rsquo;arriv√©e de cette derni√®re ne chevauche pas celle d\u0026rsquo;un autre objet.\nBien s√ªr, ici nous somme dans un environnement 3D et nous traitons des volumes, donc il ne s\u0026rsquo;agit pas simplement de v√©rifier la position d\u0026rsquo;arriv√©e de l\u0026rsquo;entit√©, mais l\u0026rsquo;enti√®ret√© de l\u0026rsquo;espace qu\u0026rsquo;elle prend.\nAABB √âtant donn√© qu\u0026rsquo;il existe une infinit√© de positions possibles dans un volume, nous allons simplifier la repr√©sentation de cet espace en utilisant une bo√Æte align√©e avec les axes, syst√®me de collision appel√© AABB pour Axis Aligned Bounding Box. Il existe d\u0026rsquo;autre repr√©sentation possible mais cette derni√®re nous convient particuli√®rement bien dans le cadre de notre moteur de voxels.\nAvec ce syst√®me, chaque entit√© poss√©dera sa boite de collision AABB qui se d√©placera en m√™me temps qu\u0026rsquo;elle, et pour v√©rifier les collisions avec les autres objets il suffira de v√©rifier leurs boite de collision entrent en intersection.\nAlgorithme Super, √ßa para√Æt simple ! Mais il y a un probl√®me : √Ä quel moment devons-nous v√©rifier une possible collision ? Apr√®s un d√©placement, vous me direz et je vous r√©pondrais que oui, mais c\u0026rsquo;est un peu plus compliqu√© que cela. Imaginez un objet qui se d√©place sur un terrain fait de plusieurs cubes. Cet objet poss√®de une vitesse de 2 en avant (comprenez qu\u0026rsquo;il se d√©place d\u0026rsquo;une distance de 2 cubes en avant). Apr√®s le d√©placement, il se retrouvera donc avanc√© de 2 cubes, et nous allons donc v√©rifier si il y a une collision sur son nouvel emplacement. Mais qu\u0026rsquo;en est-il s\u0026rsquo;il y avait un cube entre sa position de d√©part et celle d\u0026rsquo;arriv√©e ?\nVous devez maintenant comprendre le probl√®me. Bien s√ªr, dans la plupart des cas, aucun objet n\u0026rsquo;est cens√© pouvoir se d√©placer de 2 cubes en 1 frame, mais il existe plusieurs situations o√π cela peut arriver et qui sont m√™mes assez connues dans l\u0026rsquo;univers du Jeu vid√©o, qui utilisent tr√®s souvent ce syst√®me de collision. Par exemple, si la machine du joueur freeze, l\u0026rsquo;accumulation de temps √©coul√© entre 2 frames durant ce freeze va devenir tr√®s grande, et comme la plupart des jeux utilisent le temps entre les frames pour calculer la vitesse des d√©placements (pour √©viter qu\u0026rsquo;un joueur avec plus de FPS puisse aller plus vite qu\u0026rsquo;un joueur avec moins de FPS), il serait donc possible qu\u0026rsquo;un gros freeze permette de donner une v√©locit√© assez grande √† un objet pour pouvoir ignorer des collisions sur son chemin. Ce probl√®me √©tant tr√®s connu des d√©veloppeurs de jeu vid√©o, quelques fixes sont des fois mis en place pour √©viter de telles situations, comme par exemple en donnant une borne maximale au temps √©coul√© entre 2 frames. Mais du coup avec un tel fix, un joueur qui freeze trop pourrait voir l\u0026rsquo;horloge de son jeu se d√©caler lentement par rapport √† une personne qui ne freeze pas, chose que l\u0026rsquo;on veut √©viter (nous voulons que chaque joueur se retrouve dans la m√™me situation apr√®s les m√™mes inputs, ind√©pendamment de leurs machines).\nMalheureusement, il n\u0026rsquo;existe pas beaucoup de solutions document√©es en ligne pour r√©gler ce probl√®me.\nEn effet, le syst√®me que je vous ai pr√©sent√© au-dessus est en fait assez satisfaisant dans une tr√®s grande majorit√© des cas, et m√™me pour mon projet en r√©alit√© ! Donc pourquoi m\u0026rsquo;emb√™ter ? En plus, cette solution a le bon go√ªt d\u0026rsquo;√™tre tr√®s peu complexe pour la machine (je parle ici de complexit√© algorithmique).\nMais je n\u0026rsquo;ai pas envie de me satisfaire d\u0026rsquo;un syst√®me de collision que je trouve imparfait, c\u0026rsquo;est pourquoi j\u0026rsquo;ai d√©cid√© de chercher une solution !\nApr√®s pas mal de temps de r√©flexion, j\u0026rsquo;ai commenc√© √† penser √† une id√©e : et si j\u0026rsquo;utilisais le ray-casting ?\nRay-Casting L\u0026rsquo;id√©e derri√®re le ray-casting est assez simple : on part d\u0026rsquo;une position et on tire un rayon dans une direction donn√©e et on s\u0026rsquo;arr√™te lorsque notre rayon rencontre un obstacle.\nC\u0026rsquo;est un algorithme qui est assez souvent utilis√© pour faire de l\u0026rsquo;affichage et calculer de mani√®re assez pr√©cise si oui ou non un objet est visible pour l\u0026rsquo;utilisateur. Cela est aussi utilis√© pour voir si une surface est √©clair√©e ou non par une source lumineuse.\nBref, ici l\u0026rsquo;id√©e serait de s\u0026rsquo;en servir pour savoir si oui ou non notre entit√© va rencontrer un autre objet.\nEt cela tombe bien ! Il se trouve que j\u0026rsquo;ai d√©j√† impl√©ment√© un algorithme de Ray-casting pour mon moteur (code disponible ici) ! Actuellement, il ne me servait qu\u0026rsquo;√† d√©terminer les objets que l\u0026rsquo;utilisateur pointe du regard (l\u0026rsquo;objet au centre de son √©cran) et rien ne m\u0026rsquo;emp√™che de le r√©utiliser dans mon autre cas de figure.\nProbl√®me : Le ray-casting est fait pour tirer un rayon partant d\u0026rsquo;un point, pas d\u0026rsquo;un volume (ici notre bo√Æte de collision AABB). Il faut trouver une solution pour adapter l\u0026rsquo;algorithme √† un volume\u0026hellip; Et bien pourquoi ne pas effectuer un ray-casting mais en partant de chacun des sommets de notre bo√Æte de collision ?\nC\u0026rsquo;est donc ce que j\u0026rsquo;ai d√©cid√© d\u0026rsquo;impl√©menter ! Mais dans quel ordre ? Comment fait-on un ray-casting de plusieurs points en m√™me temps ? Eh bien, l\u0026rsquo;id√©e que j\u0026rsquo;ai s√©lectionn√©e est d\u0026rsquo;effectuer le ray-casting sur chacun des points de la boite de collision (8 points ici). On pourrait aussi optimiser cela en ne v√©rifiant que 7 points, car on sait qu\u0026rsquo;il y en aura toujours un qui sera couvert par les 7 autres, mais c\u0026rsquo;est un d√©tail. Ensuite, on retient la collision la plus proche obtenue avec ces 8 ray-castings et on recommence en adaptant les entr√©es, c\u0026rsquo;est-√†-dire les positions de d√©part des ray-castings et la direction :\nPosition de d√©part : On ajoute le d√©placement effectu√© jusqu\u0026rsquo;√† la collision √† toutes les positions. Direction : On ajoute le d√©placement effectu√© jusqu\u0026rsquo;√† la collision et on met √† 0 la direction dans laquelle on a rencontr√© la collision. Et √©tant donn√© que nous sommes en 3D et que nous avons \u0026ldquo;seulement\u0026rdquo; 3 axes maximum avec lesquels nous pouvons rencontrer une collision avant que notre direction ne devienne un vecteur nul, on sait que nous n\u0026rsquo;allons r√©p√©ter cet algorithme que 3 fois dans le pire des cas.\nNous allons √† chaque collision sauvegarder le d√©placement effectu√© jusqu\u0026rsquo;√† la collision, et cet algorithme retournera donc la somme de tous ces d√©placements avec le vecteur direction restant (s\u0026rsquo;il n\u0026rsquo;est pas nul).\nVoici un petit sch√©ma pour que vous puissiez essayer de visualiser l\u0026rsquo;algorithme :\nIci, les cubes verts repr√©sentent notre environnement, le cube rouge repr√©sente notre bo√Æte de collision et les fl√®ches bleues repr√©sentent les ray-castings effectu√©s !\nBon, dit comme √ßa, √ßa a l\u0026rsquo;air simple, mais en pratique, √ßa donne quoi ? Eh bien, apr√®s environ trois semaines de gal√®re en tout genre, principalement due √† des probl√®mes de nombres flottants, de calcul de longueur de vecteurs et d\u0026rsquo;intersection entre les voxels, l\u0026rsquo;algorithme fonctionne !\nPour faire simple, les principaux probl√®mes que j\u0026rsquo;ai rencontr√©s pendant ces trois semaines et leurs solutions :\nQue se passe-t-il si l\u0026rsquo;on commence un ray-casting entre deux voxels sur un axe ? Et bien le voxel ayant la coordonn√©e la plus \u0026ldquo;grande\u0026rdquo; sera arbitrairement s√©lectionn√©. C\u0026rsquo;est un comportement qu\u0026rsquo;on veut √† tout prix √©viter, car cela veut dire qu\u0026rsquo;on n\u0026rsquo;est pas s√ªr dans cette situation de bien commencer l√† o√π l\u0026rsquo;on veut le ray-casting. J\u0026rsquo;ai donc ajout√© une v√©rification pour d√©tecter cette situation, et si elle est rencontr√©e, on va bien pr√©ciser que le prochain voxel se trouve √† une distance de 0 et on va reculer notre position de 1 dans le sens inverse de notre vecteur de direction. On va aussi rajouter une distance minimale √† un voxel pour ne pas coller nos bo√Ætes de collisions √† ces derniers.\nUn autre souci que j\u0026rsquo;ai rencontr√© est une erreur basique de calcul de longueur d\u0026rsquo;un vecteur. En fait, j\u0026rsquo;estimais mal la distance parcourue pendant un ray-casting, ce qui entra√Ænait des situations o√π je ne d√©tectais pas de collisions et me retrouvais avec des coordonn√©es √† l\u0026rsquo;int√©rieur de voxels, chose que je ne pouvais pas g√©rer par la suite. Mon erreur √©tait que j\u0026rsquo;additionnais mes d√©placements sur tous les axes, et je consid√©rais ensuite cette valeur comme la distance parcourue, sauf que cela ne fonctionne pas ainsi avec des vecteurs. Si j\u0026rsquo;avance de 1 en x et 1 en y, je n\u0026rsquo;aurai pas avanc√© de 2 mais d\u0026rsquo;environ 1,41\u0026hellip; Donc pour calculer cela, rien de mieux que de stocker tous les d√©placements sur les axes dans un vecteur et ensuite calculer la longueur de ce dernier pour obtenir la distance parcourue !\nEt voil√†, avec tout √ßa, on dispose d\u0026rsquo;un algorithme de d√©tection de collision entre nos entit√©s et notre monde fonctionnel !\nVoici une vid√©o d√©mo du r√©sultat :\nBonus Maintenant que le syst√®me de collision est impl√©ment√©, il est assez simple de rajouter un petit syst√®me de simulation de gravit√© et de saut ! Voici une petite d√©mo de ce que √ßa donne :\nN‚Äôh√©sitez pas √† me contacter si vous avez des questions / suggestions.\n","permalink":"https://themagnat.github.io/blog/posts/mavoxel/collisions/","summary":"Developement d\u0026rsquo;un system de Collision pour mon moteur de voxels Mavoxel","title":"Mavoxel - Developement d'un syst√®me de Collision"}]