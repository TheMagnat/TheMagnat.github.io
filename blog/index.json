[{"content":"Introduction Cet article est un devlog parlant du choix d\u0026rsquo;une structure de donn√©es üìö pour repr√©senter un monde dans mon moteur de voxels Mavoxel üé≤.\nLors du d√©veloppement d\u0026rsquo;un projet informatique, on se retrouve tr√®s souvent (m√™me toujours) √† manipuler une grande quantit√© de donn√©es. Choisir la fa√ßon dont on va les stocker est donc une √©tape importante et risquera d\u0026rsquo;avoir un fort impact dans la suite des d√©veloppements. Si dans la plus part des langages haut niveau ce choix se r√©sume √† choir entre une list ou une map, en C++ ce choix n\u0026rsquo;est pas aussi simple. Une list assure la validit√© des r√©f√©rences sur ses objets m√™me apr√®s insertion mais ne permet par d\u0026rsquo;acc√©der √† n\u0026rsquo;importe quel √©l√©ment en temps constant et son parcours demande un peu plus de temps qu\u0026rsquo;une structure de donn√©e contigu√´ en m√©moire comme un vector.\nIci dans le cadre d\u0026rsquo;un moteur de jeux, quand il va s\u0026rsquo;agir de donn√©es √† envoyer √† notre carte graphique, nous allons quasiment exclusivement utiliser des structures contigu√´ en m√©moire, donc le vector de la libraire standard du C++.\nRepr√©sentation d\u0026rsquo;un monde de Voxels Cela √©tant dit, repr√©senter l\u0026rsquo;enti√®ret√© de notre monde fait de Voxels dans un seul vector serait un petit peu na√Øf, car cela impliquerait de devoir choisir entre ces deux sc√©narios :\nGarder l‚Äôenti√®ret√© de nos Voxels charg√©s √† chaque instant peut importe l\u0026rsquo;emplacement du joueur. Ou\nDevoir effectuer des suppression et des insertions en continue dans notre vector en fonction de l\u0026rsquo;emplacement du joueur pour supprimer les Voxels trop √©loign√© et ins√©rer les Voxels entrant dans la port√©e du joueur. Le premier sc√©nario risque de vite √™tre limit√© √† mesure que le monde du joueur grandit et le second sc√©nario risque de poser de gros soucis de performances √©tant donn√© que nous travaillons sur un vector qui utilise une m√©moire contigu√´ et que supprimer ou ins√©rer des donn√©es sur ce type de m√©moire peut √™tre co√ªteux (r√©allocation, d√©placement des objets d√©j√† ins√©r√©\u0026hellip;).\nBon de toute fa√ßon vous l\u0026rsquo;aurez s√ªrement d√©j√† devin√© et cette petite introduction √©tait s√ªrement inutile, mais dans ce type de moteur, le monde est g√©n√©ralement d√©coup√© en ce que l\u0026rsquo;on appelle des Chunks, et c\u0026rsquo;est donc l\u0026rsquo;approche que j\u0026rsquo;ai aussi d√©cid√© de suivre.\nChunks L\u0026rsquo;id√©e ici est de diviser notre monde en un ensemble de volume d\u0026rsquo;une m√™me taille que nous allons nommer des \u0026ldquo;Chunks\u0026rdquo;.\nSur cette image, vous pouvez imaginer le grand cube comme √©tant notre monde et chaque petit cube comme un Chunk.\nCe d√©coupage √† plusieurs gros avantages :\nNe pas avoir √† g√©rer une √©norme structure de donn√©es mais plusieurs plus petites. Charger et d√©charger facilement et rapidement un ensemble de voxels en fonction de leurs positions par rapport au joueur. Pouvoir parall√©liser des op√©rations comme la g√©n√©ration / le chargements des Chunks. Pouvoir r√©duire l\u0026rsquo;espace de recherche quand on effectue une op√©ration comme un calcul de collision. On sait qu\u0026rsquo;on n\u0026rsquo;a besoins d\u0026rsquo;examiner qu\u0026rsquo;un seul Chunk et a la limite ses voisins. Bien-s√ªr, il y a quand m√™me un inconv√©nient, l\u0026rsquo;acc√®s aux voisins d\u0026rsquo;un voxel n\u0026rsquo;est pas aussi trivial qu\u0026rsquo;avec une seule et unique structure de donn√©es. En effet, il faut faire quelques v√©rifications, comme s\u0026rsquo;assurer qu\u0026rsquo;on ne sort pas des limites du Chunk, auquel cas il faudra acc√©der aux donn√©es du Chunk voisin pour r√©cup√©rer le voxel convoit√©.\nMais je pense que vous en conviendrez avec moi, ce petit inconv√©nient et compl√®tement √©clips√© par tout les avantages que nous offre cette repr√©sentation de notre monde.\nBon, nous allons donc d√©couper notre monde en un nombre infini de position enti√®re dans nos 3 axes x, y et z et attribuer √† chacune de ces positions un Chunk, que nous g√©n√©rons et afficherons lorsque le joueur sera assez proche, et lorsque ce dernier s\u0026rsquo;√©loignera trop nous n\u0026rsquo;aurons plus qu\u0026rsquo;a ne plus afficher ce Chunk, voir le d√©charger de la m√©moire üòÄ !\nNous allons aussi devoir d√©finir la taille d\u0026rsquo;un Chunk. C\u0026rsquo;est √† dire, le nombre de voxels qu\u0026rsquo;il poss√©dera sur chacun de ses axes. Par exemple, il peut poss√©der 64 voxels de longueur, 64 voxels de largeur ainsi que 64 voxels de profondeur pour avoir des Chunks carr√©s. Avec une telle taille, chaque Chunk pourra contenir 64 * 64 * 64 = 262144 voxels ! Il serait aussi possible d\u0026rsquo;utiliser une taille diff√©rent pour un des axe comme l\u0026rsquo;axe y, ce qui est par exemple fait dans Minecraft.\nIci j\u0026rsquo;ai d√©cid√© d\u0026rsquo;utiliser une taille uniforme pour chaque axe, car j\u0026rsquo;aimerais accorder une certaine importance √† la verticalit√© dans mon moteur et donc ne pas limiter l\u0026rsquo;axe y.\nTout cela √©tant dit, nous allons maintenant pouvoir commencer √† impl√©menter notre Chunk en C++ !\nstruct Chunk { int x, y, z; // La position du chunk dans le monde int size; // La taille du chunk sur chaque axe QuelqueChose voxels; // ..? les voxels ? }; Bon, vous l\u0026rsquo;aviez sans doute d√©j√† remarqu√© avant, mais je n\u0026rsquo;ai toujours pas abord√© le stockage des voxels, et ce type de donn√©es \u0026ldquo;QuelqueChose\u0026rdquo; n\u0026rsquo;est d√©finitivement pas un type natif du C++ üôÉ.\nEn effet, m√™me si pendant l\u0026rsquo;introduction j\u0026rsquo;ai mentionn√© la possibilit√© d\u0026rsquo;utiliser un vector pour stocker les voxels, ce n\u0026rsquo;est pas la seule possibilit√© et nous allons m√™me rapidement voir qu\u0026rsquo;elle est loin d\u0026rsquo;√™tre optimale !\nStockage des Voxels Avant d\u0026rsquo;avancer, essayons de savoir ce que repr√©sente r√©ellement un voxel et ce que nous allons vouloir repr√©senter dans notre m√©moire.\nOn peut voir un voxel comme un simple cube. Dans notre monde et donc dans nos Chunks, chaque voxel est de la m√™me taille et poss√®de sa propre position. Sur une position donn√©e, un voxel prendra l\u0026rsquo;enti√®ret√© de l\u0026rsquo;espace jusqu\u0026rsquo;aux limites de sa positions (donc jusqu\u0026rsquo;aux voxels voisins).\nVoil√†, donc avec simplement une position, on peut repr√©senter un voxel ! Bon, on aimerait aussi pouvoir donne un style √† chaque voxel pour √©viter de se retrouver avec des voxels tous identiques. Ici plusieurs possibilit√©s :\nStocker dans chaque voxel un Material (Un Material repr√©sente souvent un ensemble de couleur d√©finissant comment un objet devra r√©agir √† la lumi√®re). Stocker un identifiant d√©finissant le type de surface que repr√©sente le voxel (Chaque identifiant √©tant donc reli√© √† un Material). Bien que la premi√®re approche permette une totale libert√© sur les possibilit√©s de surfaces pour les voxels (et ce m√™me de mani√®re dynamique), sur un terrain nous ne voulons de toute fa√ßon pas permettre un nombre infini de type de surfaces.\nLa seconde approche a l\u0026rsquo;avantage d\u0026rsquo;√™tre BEAUCOUP moins co√ªteuse en place, l√† ou la premi√®re n√©cessiterais de stocker au moins 3 couleurs et un flottant pour chaque voxels (donc 3 * 3 + 1 = 10 flottants par voxel), la seconde approche permet de ne stocker que un entier pour chaque voxel.\nDonc pour r√©sumer, voici √† quoi devrait ressembler une structure Voxel :\nstruct Voxel { int x, y, z; // Position dans le chunk int id; // L\u0026#39;identifiant du voxel }; Maintenant, voyons comment nous allons pouvoir stocker nos voxels dans nos Chunks !\nLe simple Vector Bon, on en parle depuis l\u0026rsquo;introduction donc vous avez du le voir venir, mais la premi√®re approche, la plus simple mais aussi la plus na√Øve de toutes ü§™, stockers les voxels de notre Chunk dans un vector !\nIl nous suffit donc de cr√©er un vector de Voxel :\nvector\u0026lt;Voxel\u0026gt; data; Cette approche poss√®de plusieurs probl√®mes majeurs. Premi√®rement, on ne tire aucunement partie de la forme particuli√®re de notre Chunk qui est un volume cubique pour les informations de positions. Mais surtout, v√©rifier la pr√©sence d\u0026rsquo;un voxel sur une position pr√©cise au sein d\u0026rsquo;un Chunk est extr√™mement co√ªteux car il n\u0026rsquo;y a pas d\u0026rsquo;autres moyens que de parcourir le vector entier et tester les positions de tous les voxels. Cette op√©ration risquant d\u0026rsquo;√™tre tr√®s courante dans notre moteur (Calculs de collisions, s√©lection, occlusion ambiante\u0026hellip;) nous allons √©viter cette mod√©lisation.\nLa Grille Comment tirer partie de la forme de notre Chunk qui est en fait un volume cubique ? Et bien en stockant nos voxels sous la forme d\u0026rsquo;une grille !\nL\u0026rsquo;avantage d\u0026rsquo;une telle structure de donn√©es est qu\u0026rsquo;il est possible de savoir la pr√©sence ou non d\u0026rsquo;un voxel sur une position dans notre Chunk instantan√©ment contrairement au simple vector !\narray\u0026lt;array\u0026lt;array\u0026lt;int, 64\u0026gt;, 64\u0026gt;, 64\u0026gt; data; ou\nint data[64][64][64]; La structure d\u0026rsquo;une grille permet donc de stocker l\u0026rsquo;information de la position naturellement via les index des donn√©s dans la grille, permettant ainsi de n\u0026rsquo;avoir √† stocker que l\u0026rsquo;identifiants de nos voxel !\nIndex ? Pour les personnes qui ne sont pas famili√®res avec ce qu\u0026rsquo;est un \u0026ldquo;index\u0026rdquo;, il s\u0026rsquo;agit simplement du num√©ro d\u0026rsquo;un √©l√©ment dans nos donn√©es. Par exemple si je cr√©√© le tableau suivant :\nint mon_tableau[5] = [7, 5, 1, 6, 3]; Je peux dire que l\u0026rsquo;√©l√©ment 7 est √† l\u0026rsquo;index 0 et l\u0026rsquo;√©l√©ment 6 est √† l\u0026rsquo;index 3. Notez que dans la plus part des langages informatiques (et donc en C++), les index commencent √† 0.\nDans notre grille, on peut donc par exemple acc√©der √† l\u0026rsquo;√©l√©ment en position x = 14, z = 6 et z = 61 en faisant data[14][6][61]. L\u0026rsquo;acc√®s est donc en temps constant et la v√©rification de la pr√©sence ou non d\u0026rsquo;un voxel sur une certaine position dans nos Chunks est quasiment instantan√© (notez qu\u0026rsquo;on conservera l\u0026rsquo;identifiant de voxel 0 comme repr√©sentant le vide), ce qui est un √©norme avantage par rapport au simple vector.\nMalheureusement, √ßa ne peut pas √™tre aussi simple, il y a deux soucis avec cette repr√©sentation :\nL\u0026rsquo;espace : Cette repr√©sentation n√©cessite de devoir initialiser l\u0026rsquo;enti√®ret√© des voxels possible dans notre Chunk, for√ßant un Chunk vide √† prendre autant de place en m√©moire qu\u0026rsquo;un Chunk remplie (m√™me si l\u0026rsquo;espace est vide, ces positions seront occup√© par des identifiants 0 repr√©sentant donc ce vide). L\u0026rsquo;acc√®s : Et l√† vous allez me dire : \u0026ldquo;Mais je pensais que l\u0026rsquo;acc√®s √©tait justement le point fort des grilles ?\u0026rdquo;. Alors oui\u0026hellip; mais aussi non. En effet, acc√©der √† l\u0026rsquo;information \u0026ldquo;existe-t-il un voxel sur cette position ?\u0026rdquo; est tr√®s rapide, mais acc√©der √† la totalit√© des voxels est plus compliqu√©. Il faut pour cela parcourir l\u0026rsquo;int√©gralit√© de la grille et v√©rifier tout les √©l√©ments qui ne sont pas √©gale √† 0. On remarquera que ces deux soucis ne sont pas pr√©sent avec la repr√©sentation dans un simple vector. Particuli√®rement le second, qui risque de ralentir la creation des donn√©es d\u0026rsquo;affichage √† envoyer √† la carte graphique si on imagine un syst√®me de rendu traditionnelle avec donc la creation d\u0026rsquo;une \u0026ldquo;mesh\u0026rdquo; (Pas besoins de s\u0026rsquo;attarder sur ce terme ici, il faut juste noter qu\u0026rsquo;on aimerais simplement pouvoir r√©cup√©rer tous les voxels existant sans devoir parcourir tout les espaces vide de notre grille).\nGrille + Vector ü•∞ Pour r√©sumer, on aime la grille pour son acc√®s en temps contant √† un voxel en fonction de sa position, et on aime le vector pour le parcours de tout les voxels rapide. Et si on combinais ces deux structures ?\nvector\u0026lt;Voxel\u0026gt; data; int posToIndex[64][64][64]; L\u0026rsquo;id√©e ici va √™tre d\u0026rsquo;avoir notre grille qui va venir stocker l\u0026rsquo;index des voxels plac√©s et toujours notre vector pour stocker tous nos voxels de fa√ßon contigu√´ !\nOn peut donc imaginer utiliser ces deux structures comme ceci :\nPour ins√©rer un nouveau voxel :\nposToIndex[voxel.x][voxel.y][voxel.z] = data.size(); data.push_back(voxel); // push_back permet d\u0026#39;ins√©rer un nouvel √©l√©ment Pour r√©cup√©rer un voxel en fonction de sa position :\nint index = posToIndex[position.x][position.y][position.z]; Voxel voxel = data[index]; Voil√†, simple mais efficace ! Bien s√ªr, on garde toujours l‚Äôinconv√©nient de m√©moire de la grille, mais on va dire qu\u0026rsquo;on est pr√™t √† faire ce sacrifice pour b√©n√©ficier des avantages de nos deux structures de donn√©es !\nCe mode de stockage √©tait celui que j\u0026rsquo;utilisais sur le projet Mavoxel au d√©but et √©tait plut√¥t efficace pour la plus part des op√©rations dans un syst√®me de rendu classique, mais le projet √† r√©cemment √©volu√© vers un nouveau mode de rendu, le Ray-Tracing, apportant de nouvelles probl√©matiques.\nRay-Tracing et Structure de donn√©es Bon, sans rentrer dans trop de d√©tails technique (et puis je compte s√ªrement √©crire un article sur l\u0026rsquo;impl√©mentation du Ray-Tracing dans Mavoxel qui d√©taillera un peu plus son fonctionnement), j\u0026rsquo;ai fais le choix de convertir le moteur de rendu en passant d\u0026rsquo;un rendu \u0026ldquo;classique\u0026rdquo; √† un rendu en Ray-Tracing.\nRapidement, comment rend-t-on une sc√®ne avec des techniques de Ray-Tracing ? On va se center sur notre cam√©ra et on va tirer un \u0026ldquo;rayon\u0026rdquo; tout droit pour chaque pixel de notre √©cran. Ce rayon doit parcourir notre scene jusqu\u0026rsquo;a rencontrer un obstacle ou bien atteindre une distance limite. La couleur qui sera alors affich√© √† l\u0026rsquo;√©cran d√©pendra de l\u0026rsquo;objet touch√© !\nVoici un sch√©ma qui r√©sume assez bien ce fonctionnement :\nBon, pour afficher notre scene nous devons envoyer notre terrain √† notre carte graphique puis tester pour chaque pixel si nous rencontrons un voxel ou non.\nIci, le format grille se pr√™te beaucoup plus √† la t√¢che que le format simple vector. Avec un simple vector, nous devrions tester chaque voxel de notre terrain pour chacun des pixel de notre rendu. Un calcul beaucoup trop complexe bien que les cartes graphiques soit optimiser pour effectuer des calculs en parall√®les, on parle ici d\u0026rsquo;une centaine de millier voir de millions de voxels, et donc le m√™me nombre de tests.\nSans trop rentrer dans les d√©tails, en envoyant la grille √† notre carte graphique, nous pouvons appliqu√© un algorithme un peu plus intelligent pour effectuer le Ray-Tracing sur notre monde. Nous allons traverser la grille en avan√ßant dans la direction de la cam√©ra, voxel par voxel.\nVoici un petit sch√©ma expliquant rapidement l\u0026rsquo;id√©e derri√®re l\u0026rsquo;algorithme :\nAvec un tel algorithme, on est capable d\u0026rsquo;atteindre des performance en Ray-Tracing acceptable, avec une distance d\u0026rsquo;affichage d\u0026rsquo;environ 256 voxels. Mais m√™me si c\u0026rsquo;est acceptable, cela reste assez faible. Nous devons trouver un moyen de repr√©senter nos donn√©es qui pourrait permettre d\u0026rsquo;acc√©l√©rer le Ray-Tracing.\nMaintenant, si je vous disais qu\u0026rsquo;il existe une repr√©sentation qui permet une telle prouesse mais qui en plus permet aussi de r√©duire l\u0026rsquo;espace occup√© par les voxels, vous me croiriez ?\nSparsed Voxel Octree Oula, c\u0026rsquo;est quoi ce nom barbare me direz vous ? Et bien √ßa les amis, c\u0026rsquo;est une structure de donn√©es super ing√©nieuse, qui va nous permettre de r√©duire drastiquement nos temps de calculs lors d\u0026rsquo;un Ray-Tracing mais aussi de r√©duire la m√©moire occup√© par nos voxels !\nUn Sparsed Voxel Octree (que l\u0026rsquo;on appellera dor√©navant SVO si √ßa ne vous d√©range pas üòâ) est une forme particuli√®re d\u0026rsquo;Octree. Sans rentrer dans les d√©tails, un Octree est une structure de donn√©es permettant de diviser un espace en plusieurs sous espace, eux m√™me aussi diviser jusqu\u0026rsquo;√† ce que ces sous espace soit compl√®tement vide ou compl√®tement plein.\nUn Octree est donc assez g√©n√©ral et peut √™tre utilis√© pour repr√©senter l\u0026rsquo;occupation d\u0026rsquo;un espace par diff√©rents types d\u0026rsquo;objets. Mais ici nous allons nous int√©resser √† sa variante, le SVO, qui comme son nom l\u0026rsquo;indique sert √† repr√©senter l\u0026rsquo;occupation d\u0026rsquo;un espace par des voxels.\nL\u0026rsquo;id√©e derri√®re cette structure de donn√©es est la suivante :\nOn choisit une taille pour notre SVO qui doit √™tre une puissance de 2 (Par exemple 64). On divise l\u0026rsquo;espace de notre SVO en 8 parts √©gales, s√©par√© au milieu des 3 axes (donc sur la coordonn√©e 32 dans notre exemple). Pour chacun des sous-espace cr√©√©, on v√©rifie si les voxels qu\u0026rsquo;il englobe sont tous du m√™me type (Comprendre ici qu\u0026rsquo;ils ont tous le m√™me identifiant, 0 √©tant consid√©r√© comme du vide). Si c\u0026rsquo;est le cas, on peut s\u0026rsquo;arr√™ter ici, sinon on r√©p√®te l\u0026rsquo;√©tape 2 (Cette fois-ci sur la coordonn√©e 16, puis 8, 4 et 2). Apr√®s toutes ces √©tapes, on est assur√© que chaque sous-espace de notre SVO est enti√®rement compos√© du m√™me type de voxel ou de vide. Bon, √ßa fais beaucoup, donc rien de mieux qu\u0026rsquo;un petit sch√©ma pour r√©sumer tout √ßa !\nEt un petit sch√©ma pour imager le passage d\u0026rsquo;une grille √† un SVO :\nJe pense que vous pouvez assez clairement voir en quoi cette repr√©sentation permet de gagner de la m√©moire, mais par-contre, en quoi va-t-elle nous aider pour notre Ray-Tracing ? Et bien, si on reprend notre pr√©c√©dent algorithme qui nous faisais parcourir les voxels de notre grille en suivant la direction de notre cam√©ra, on peut faire la m√™me chose ici mais en sautant directement les portions vide. On peut d√©j√† imaginer une grille qui √©tait totalement vide mais qui prenait quand m√™me 64 it√©ration pour √™tre parcouru par notre algorithme de Ray-Tracing sur sa longueur, l√† o√π avec notre SVO et notre version adapt√© de notre algorithme, cela ne prendra plus que 4 it√©rations !\nVoici un petit sch√©ma pour mieux visualiser la logique derri√®re ce nouvel algorithme :\nIl y a quand m√™me toujours deux inconv√©nients :\nToujours l‚Äôacc√®s : Et oui, comme pour la grille, r√©cup√©rer la liste compl√®te des voxels pr√©sent dans notre Chunk sans avoir de vector est une t√¢che co√ªteuse ! Mais √©tant donn√© que nous allons remplacer notre mode de rendu classique par le rendu en Ray-Tracing, nous n\u0026rsquo;aurons plus vraiment besoins de r√©cup√©rer une telle liste. Plus lent pour r√©cup√©rer une position : Contrairement √† la grille qui permettait de r√©cup√©rer instantan√©ment un voxel en fonction d\u0026rsquo;une position, dans notre SVO cet op√©ration est l√©g√®rement plus co√ªteuse, cela reste beaucoup, beaucoup plus rapide qu\u0026rsquo;avec un simple vector et on pourra n√©gliger ce co√ªt, mais il est quand m√™me important de le mentionner. Mais malgr√© ces deux points, la structure de donn√©es SVO reste extr√™mement int√©ressante et nous permet d\u0026rsquo;obtenir les meilleurs performances en temps r√©el avec l\u0026rsquo;algorithme de Ray-Tracing, tout en conservant une occupation de la m√©moire plus que raisonnable !\nMalheureusement et pour votre plus grande tristesse, je n\u0026rsquo;ai pas de d√©monstration √† vous pr√©senter pour conclure cet article ü•∫. En effet il est assez difficile montrer l\u0026rsquo;impl√©mentation d\u0026rsquo;une nouvelle structure de donn√©es, mais je vais promet que pour le prochain article sur le Ray-Tracing, vous pourrez voir √† l\u0026rsquo;oeuvre toute la puissance du SVO !\nSi vous avez une remarque ou des questions, ou si vous √™tes int√©ress√© pour parler un peu plus de l\u0026rsquo;impl√©mentation du SVO, n\u0026rsquo;h√©sitez pas √† me contacter, vous pouvez retrouver mon email sur mon site personnel en entrant la commande CONTACT !\n","permalink":"https://themagnat.github.io/blog/posts/mavoxel/datarepresentation/","summary":"Quelle structure de donn√©es est la plus adapt√©e pour repr√©senter un monde fait de Voxels ? Je vous parle de mon choix de structure de donn√©es pour Mavoxel.","title":"Mavoxel - Repr√©sentations en m√©moire d'un monde de Voxels"},{"content":"Introduction Cet article est un devlog parlant de l\u0026rsquo;impl√©mentation d\u0026rsquo;un syst√®me de collision pour mon moteur de voxels Mavoxel üòâ.\nLe principe d\u0026rsquo;une collision est assez simple : si une entit√© est en mouvement, on va s\u0026rsquo;assurer que la position d\u0026rsquo;arriv√©e de cette derni√®re ne chevauche pas celle d\u0026rsquo;un autre objet.\nBien s√ªr, ici nous somme dans un environnement 3D et nous traitons des volumes, donc il ne s\u0026rsquo;agit pas simplement de v√©rifier la position d\u0026rsquo;arriv√©e de l\u0026rsquo;entit√©, mais l\u0026rsquo;enti√®ret√© de l\u0026rsquo;espace qu\u0026rsquo;elle prend.\nAABB √âtant donn√© qu\u0026rsquo;il existe une infinit√© de positions possibles dans un volume, nous allons simplifier la repr√©sentation de cet espace en utilisant une bo√Æte align√©e avec les axes, syst√®me de collision appel√© AABB pour Axis Aligned Bounding Box. Il existe d\u0026rsquo;autre repr√©sentation possible mais cette derni√®re nous convient particuli√®rement bien dans le cadre de notre moteur de voxels.\nAvec ce syst√®me, chaque entit√© poss√©dera sa boite de collision AABB qui se d√©placera en m√™me temps qu\u0026rsquo;elle, et pour v√©rifier les collisions avec les autres objets il suffira de v√©rifier leurs boite de collision entrent en intersection.\nAlgorithme Super, √ßa para√Æt simple ! Mais il y a un probl√®me : √Ä quel moment devons-nous v√©rifier une possible collision ? Apr√®s un d√©placement, vous me direz et je vous r√©pondrais que oui, mais c\u0026rsquo;est un peu plus compliqu√© que cela. Imaginez un objet qui se d√©place sur un terrain fait de plusieurs cubes. Cet objet poss√®de une vitesse de 2 en avant (comprenez qu\u0026rsquo;il se d√©place d\u0026rsquo;une distance de 2 cubes en avant). Apr√®s le d√©placement, il se retrouvera donc avanc√© de 2 cubes, et nous allons donc v√©rifier si il y a une collision sur son nouvel emplacement. Mais qu\u0026rsquo;en est-il s\u0026rsquo;il y avait un cube entre sa position de d√©part et celle d\u0026rsquo;arriv√©e ?\nVous devez maintenant comprendre le probl√®me. Bien s√ªr, dans la plupart des cas, aucun objet n\u0026rsquo;est cens√© pouvoir se d√©placer de 2 cubes en 1 frame, mais il existe plusieurs situations o√π cela peut arriver et qui sont m√™mes assez connues dans l\u0026rsquo;univers du Jeu vid√©o, qui utilisent tr√®s souvent ce syst√®me de collision. Par exemple, si la machine du joueur freeze, l\u0026rsquo;accumulation de temps √©coul√© entre 2 frames durant ce freeze va devenir tr√®s grande, et comme la plupart des jeux utilisent le temps entre les frames pour calculer la vitesse des d√©placements (pour √©viter qu\u0026rsquo;un joueur avec plus de FPS puisse aller plus vite qu\u0026rsquo;un joueur avec moins de FPS), il serait donc possible qu\u0026rsquo;un gros freeze permette de donner une v√©locit√© assez grande √† un objet pour pouvoir ignorer des collisions sur son chemin. Ce probl√®me √©tant tr√®s connu des d√©veloppeurs de jeu vid√©o, quelques fixes sont des fois mis en place pour √©viter de telles situations, comme par exemple en donnant une borne maximale au temps √©coul√© entre 2 frames. Mais du coup avec un tel fix, un joueur qui freeze trop pourrait voir l\u0026rsquo;horloge de son jeu se d√©caler lentement par rapport √† une personne qui ne freeze pas, chose que l\u0026rsquo;on veut √©viter (nous voulons que chaque joueur se retrouve dans la m√™me situation apr√®s les m√™mes inputs, ind√©pendamment de leurs machines).\nMalheureusement, il n\u0026rsquo;existe pas beaucoup de solutions document√©es en ligne pour r√©gler ce probl√®me.\nEn effet, le syst√®me que je vous ai pr√©sent√© au-dessus est en fait assez satisfaisant dans une tr√®s grande majorit√© des cas, et m√™me pour mon projet en r√©alit√© ! Donc pourquoi m\u0026rsquo;emb√™ter ? En plus, cette solution a le bon go√ªt d\u0026rsquo;√™tre tr√®s peu complexe pour la machine (je parle ici de complexit√© algorithmique).\nMais je n\u0026rsquo;ai pas envie de me satisfaire d\u0026rsquo;un syst√®me de collision que je trouve imparfait, c\u0026rsquo;est pourquoi j\u0026rsquo;ai d√©cid√© de chercher une solution !\nApr√®s pas mal de temps de r√©flexion, j\u0026rsquo;ai commenc√© √† penser √† une id√©e : et si j\u0026rsquo;utilisais le Ray-Casting ?\nRay-Casting L\u0026rsquo;id√©e derri√®re le Ray-Casting est assez simple : on part d\u0026rsquo;une position et on tire un rayon dans une direction donn√©e et on s\u0026rsquo;arr√™te lorsque notre rayon rencontre un obstacle.\nC\u0026rsquo;est un algorithme qui est assez souvent utilis√© pour faire de l\u0026rsquo;affichage et calculer de mani√®re assez pr√©cise si oui ou non un objet est visible pour l\u0026rsquo;utilisateur. Cela est aussi utilis√© pour voir si une surface est √©clair√©e ou non par une source lumineuse.\nBref, ici l\u0026rsquo;id√©e serait de s\u0026rsquo;en servir pour savoir si oui ou non notre entit√© va rencontrer un autre objet.\nEt cela tombe bien ! Il se trouve que j\u0026rsquo;ai d√©j√† impl√©ment√© un algorithme de Ray-Casting pour mon moteur (code disponible ici) ! Actuellement, il ne me servait qu\u0026rsquo;√† d√©terminer les objets que l\u0026rsquo;utilisateur pointe du regard (l\u0026rsquo;objet au centre de son √©cran) et rien ne m\u0026rsquo;emp√™che de le r√©utiliser dans mon autre cas de figure.\nProbl√®me : Le Ray-Casting est fait pour tirer un rayon partant d\u0026rsquo;un point, pas d\u0026rsquo;un volume (ici notre bo√Æte de collision AABB). Il faut trouver une solution pour adapter l\u0026rsquo;algorithme √† un volume\u0026hellip; Et bien pourquoi ne pas effectuer un Ray-Casting mais en partant de chacun des sommets de notre bo√Æte de collision ?\nC\u0026rsquo;est donc ce que j\u0026rsquo;ai d√©cid√© d\u0026rsquo;impl√©menter ! Mais dans quel ordre ? Comment fait-on un Ray-Casting de plusieurs points en m√™me temps ? Eh bien, l\u0026rsquo;id√©e que j\u0026rsquo;ai s√©lectionn√©e est d\u0026rsquo;effectuer le Ray-Casting sur chacun des points de la boite de collision (8 points ici). On pourrait aussi optimiser cela en ne v√©rifiant que 7 points, car on sait qu\u0026rsquo;il y en aura toujours un qui sera couvert par les 7 autres, mais c\u0026rsquo;est un d√©tail. Ensuite, on retient la collision la plus proche obtenue avec ces 8 Ray-Castings et on recommence en adaptant les entr√©es, c\u0026rsquo;est-√†-dire les positions de d√©part des Ray-Castings et la direction :\nPosition de d√©part : On ajoute le d√©placement effectu√© jusqu\u0026rsquo;√† la collision √† toutes les positions. Direction : On ajoute le d√©placement effectu√© jusqu\u0026rsquo;√† la collision et on met √† 0 la direction dans laquelle on a rencontr√© la collision. Et √©tant donn√© que nous sommes en 3D et que nous avons \u0026ldquo;seulement\u0026rdquo; 3 axes maximum avec lesquels nous pouvons rencontrer une collision avant que notre direction ne devienne un vecteur nul, on sait que nous n\u0026rsquo;allons r√©p√©ter cet algorithme que 3 fois dans le pire des cas.\nNous allons √† chaque collision sauvegarder le d√©placement effectu√© jusqu\u0026rsquo;√† la collision, et cet algorithme retournera donc la somme de tous ces d√©placements avec le vecteur direction restant (s\u0026rsquo;il n\u0026rsquo;est pas nul).\nVoici un petit sch√©ma pour que vous puissiez essayer de visualiser l\u0026rsquo;algorithme :\nIci, les cubes verts repr√©sentent notre environnement, le cube rouge repr√©sente notre bo√Æte de collision et les fl√®ches bleues repr√©sentent les Ray-Castings effectu√©s !\nBon, dit comme √ßa, √ßa a l\u0026rsquo;air simple, mais en pratique, √ßa donne quoi ? Eh bien, apr√®s environ trois semaines de gal√®re en tout genre, principalement due √† des probl√®mes de nombres flottants, de calcul de longueur de vecteurs et d\u0026rsquo;intersection entre les voxels, l\u0026rsquo;algorithme fonctionne !\nPour faire simple, les principaux probl√®mes que j\u0026rsquo;ai rencontr√©s pendant ces trois semaines et leurs solutions :\nQue se passe-t-il si l\u0026rsquo;on commence un Ray-Casting entre deux voxels sur un axe ? Et bien le voxel ayant la coordonn√©e la plus \u0026ldquo;grande\u0026rdquo; sera arbitrairement s√©lectionn√©. C\u0026rsquo;est un comportement qu\u0026rsquo;on veut √† tout prix √©viter, car cela veut dire qu\u0026rsquo;on n\u0026rsquo;est pas s√ªr dans cette situation de bien commencer l√† o√π l\u0026rsquo;on veut le Ray-Casting. J\u0026rsquo;ai donc ajout√© une v√©rification pour d√©tecter cette situation, et si elle est rencontr√©e, on va bien pr√©ciser que le prochain voxel se trouve √† une distance de 0 et on va reculer notre position de 1 dans le sens inverse de notre vecteur de direction. On va aussi rajouter une distance minimale √† un voxel pour ne pas coller nos bo√Ætes de collisions √† ces derniers.\nUn autre souci que j\u0026rsquo;ai rencontr√© est une erreur basique de calcul de longueur d\u0026rsquo;un vecteur. En fait, j\u0026rsquo;estimais mal la distance parcourue pendant un Ray-Casting, ce qui entra√Ænait des situations o√π je ne d√©tectais pas de collisions et me retrouvais avec des coordonn√©es √† l\u0026rsquo;int√©rieur de voxels, chose que je ne pouvais pas g√©rer par la suite. Mon erreur √©tait que j\u0026rsquo;additionnais mes d√©placements sur tous les axes, et je consid√©rais ensuite cette valeur comme la distance parcourue, sauf que cela ne fonctionne pas ainsi avec des vecteurs. Si j\u0026rsquo;avance de 1 en x et 1 en y, je n\u0026rsquo;aurai pas avanc√© de 2 mais d\u0026rsquo;environ 1,41\u0026hellip; Donc pour calculer cela, rien de mieux que de stocker tous les d√©placements sur les axes dans un vecteur et ensuite calculer la longueur de ce dernier pour obtenir la distance parcourue !\nEt voil√†, avec tout √ßa, on dispose d\u0026rsquo;un algorithme de d√©tection de collision entre nos entit√©s et notre monde fonctionnel !\nVoici une vid√©o d√©mo du r√©sultat :\nBonus Maintenant que le syst√®me de collision est impl√©ment√©, il est assez simple de rajouter un petit syst√®me de simulation de gravit√© et de saut ! Voici une petite d√©mo de ce que √ßa donne :\nN‚Äôh√©sitez pas √† me contacter si vous avez des questions / suggestions.\n","permalink":"https://themagnat.github.io/blog/posts/mavoxel/collisions/","summary":"Je retrace mes r√©flexions et le development d\u0026rsquo;un system de Collision pour Mavoxel.","title":"Mavoxel - Developement d'un syst√®me de Collision"}]