<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Collisions | DevBlog de Magnat</title>
<meta name="keywords" content="Mavoxel, Ray-Casting">
<meta name="description" content="Developement d&rsquo;un system de Collision pour mon moteur de voxels Mavoxel">
<meta name="author" content="Guillaume Magniadas">
<link rel="canonical" href="https://themagnat.github.io/blog/posts/mavoxel/collisions/">
<link crossorigin="anonymous" href="/blog/assets/css/stylesheet.bf5f9f73cf17311d52cedbcda82c922e91b2f566d88a85ad9f5b5a08b586bd5f.css" integrity="sha256-v1&#43;fc88XMR1SztvNqCySLpGy9WbYioWtn1taCLWGvV8=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/blog/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://themagnat.github.io/blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://themagnat.github.io/blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://themagnat.github.io/blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://themagnat.github.io/blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://themagnat.github.io/blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Collisions" />
<meta property="og:description" content="Developement d&rsquo;un system de Collision pour mon moteur de voxels Mavoxel" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://themagnat.github.io/blog/posts/mavoxel/collisions/" /><meta property="og:image" content="https://themagnat.github.io/blog/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-08T14:53:43+02:00" />
<meta property="article:modified_time" content="2023-08-08T14:53:43+02:00" />


<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://themagnat.github.io/blog/papermod-cover.png"/>

<meta name="twitter:title" content="Collisions"/>
<meta name="twitter:description" content="Developement d&rsquo;un system de Collision pour mon moteur de voxels Mavoxel"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://themagnat.github.io/blog/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Collisions",
      "item": "https://themagnat.github.io/blog/posts/mavoxel/collisions/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Collisions",
  "name": "Collisions",
  "description": "Developement d\u0026rsquo;un system de Collision pour mon moteur de voxels Mavoxel",
  "keywords": [
    "Mavoxel", "Ray-Casting"
  ],
  "articleBody": "Introduction Cet article est un devlog parlant de l’implémentation d’un système de collision pour mon moteur de voxels Mavoxel.\nLe principe d’une collision est assez simple : si une entité est en mouvement, on va s’assurer que la position d’arrivée de cette dernière ne chevauche pas celle d’un autre objet.\nBien sûr, ici nous somme dans un environnement 3D et nous traitons des volumes, donc il ne s’agit pas simplement de vérifier la position d’arrivée de l’entité, mais l’entièreté de l’espace qu’elle prend.\nAABB Étant donné qu’il existe une infinité de positions possibles dans un volume, nous allons simplifier la représentation de cet espace en utilisant une boîte alignée avec les axes, système de collision appelé “AABB” pour “Axis Aligned Bounding Box”. Il existe d’autre représentation possible mais cette dernière nous convient particulièrement bien dans le cadre de notre moteur de voxels.\nAvec ce système, chaque entité possèdera sa boite de collision “AABB” qui se déplacera en même temps qu’elle, et pour vérifier les collisions avec les autres objets il suffira de vérifier leurs boite de collision entrent en intersection.\nAlgorithme Super, ça paraît simple ! Mais il y a un problème : À quel moment devons-nous vérifier une possible collision ? Après un déplacement, vous me direz et je vous répondrais que oui, mais c’est un peu plus compliqué que cela. Imaginez un objet qui se déplace sur un terrain fait de plusieurs cubes. Cet objet possède une vitesse de 2 en avant (comprenez qu’il se déplace d’une distance de 2 cubes en avant). Après le déplacement, il se retrouvera donc avancé de 2 cubes, et nous allons donc vérifier si il y a une collision sur son nouvel emplacement. Mais qu’en est-il s’il y avait un cube entre sa position de départ et celle d’arrivée ?\nVous devez maintenant comprendre le problème. Bien sûr, dans la plupart des cas, aucun objet n’est censé pouvoir se déplacer de 2 cubes en 1 frame, mais il existe plusieurs situations où cela peut arriver et qui sont mêmes assez connues dans l’univers du Jeu vidéo, qui utilisent très souvent ce système de collision. Par exemple, si la machine du joueur freeze, l’accumulation de temps écoulé entre 2 frames durant ce freeze va devenir très grande, et comme la plupart des jeux utilisent le temps entre les frames pour calculer la vitesse des déplacements (pour éviter qu’un joueur avec plus de FPS puisse aller plus vite qu’un joueur avec moins de FPS), il serait donc possible qu’un gros freeze permette de donner une vélocité assez grande à un objet pour pouvoir ignorer des collisions sur son chemin. Ce problème étant très connu des développeurs de jeu vidéo, quelques fixes sont des fois mis en place pour éviter de telles situations, comme par exemple en donnant une borne maximale au temps écoulé entre 2 frames. Mais du coup avec un tel fix, un joueur qui freeze trop pourrait voir l’horloge de son jeu se décaler lentement par rapport à une personne qui ne freeze pas, chose que l’on veut éviter (nous voulons que chaque joueur se retrouve dans la même situation après les mêmes inputs, indépendamment de leurs machines).\nMalheureusement, il n’existe pas beaucoup de solutions documentées en ligne pour régler ce problème.\nEn effet, le système que je vous ai présenté au-dessus est en fait assez satisfaisant dans une très grande majorité des cas, et même pour mon projet en réalité ! Donc pourquoi m’embêter ? En plus, cette solution a le bon goût d’être très peu complexe pour la machine (je parle ici de complexité algorithmique).\nMais je n’ai pas envie de me satisfaire d’un système de collision que je trouve imparfait, c’est pourquoi j’ai décidé de chercher une solution !\nAprès pas mal de temps de réflexion, j’ai commencé à penser à une idée : et si j’utilisais le ray-casting ?\nRay-Casting L’idée derrière le ray-casting est assez simple : on part d’une position et on tire un rayon dans une direction donnée et on s’arrête lorsque notre rayon rencontre un obstacle.\nC’est un algorithme qui est assez souvent utilisé pour faire de l’affichage et calculer de manière assez précise si oui ou non un objet est visible pour l’utilisateur. Cela est aussi utilisé pour voir si une surface est éclairée ou non par une source lumineuse.\nBref, ici l’idée serait de s’en servir pour savoir si oui ou non notre entité va rencontrer un autre objet.\nEt cela tombe bien ! Il se trouve que j’ai déjà implémenté un algorithme de Ray-casting pour mon moteur (code disponible ici) ! Actuellement, il ne me servait qu’à déterminer les objets que l’utilisateur pointe du regard (l’objet au centre de son écran) et rien ne m’empêche de le réutiliser dans mon autre cas de figure.\nProblème : Le ray-casting est fait pour tirer un rayon partant d’un point, pas d’un volume (ici notre boîte de collision AABB). Il faut trouver une solution pour adapter l’algorithme à un volume… Et bien pourquoi ne pas effectuer un ray-casting mais en partant de chacun des sommets de notre boîte de collision ?\nC’est donc ce que j’ai décidé d’implémenter ! Mais dans quel ordre ? Comment fait-on un ray-casting de plusieurs points en même temps ? Eh bien, l’idée que j’ai sélectionnée est d’effectuer le ray-casting sur chacun des points de la boite de collision (8 points ici). On pourrait aussi optimiser cela en ne vérifiant que 7 points, car on sait qu’il y en aura toujours un qui sera couvert par les 7 autres, mais c’est un détail. Ensuite, on retient la collision la plus proche obtenue avec ces 8 ray-castings et on recommence en adaptant les entrées, c’est-à-dire les positions de départ des ray-castings et la direction :\nPosition de départ : On ajoute le déplacement effectué jusqu’à la collision à toutes les positions. Direction : On ajoute le déplacement effectué jusqu’à la collision et on met à 0 la direction dans laquelle on a rencontré la collision. Et étant donné que nous sommes en 3D et que nous avons “seulement” 3 axes maximum avec lesquels nous pouvons rencontrer une collision avant que notre direction ne devienne un vecteur nul, on sait que nous n’allons répéter cet algorithme que 3 fois dans le pire des cas.\nNous allons à chaque collision sauvegarder le déplacement effectué jusqu’à la collision, et cet algorithme retournera donc la somme de tous ces déplacements avec le vecteur direction restant (s’il n’est pas nul).\nVoici un petit schéma pour que vous puissiez essayer de visualiser l’algorithme :\nIci, les cubes verts représentent notre environnement, le cube rouge représente notre boîte de collision et les flèches bleues représentent les ray-castings effectués !\nBon, dit comme ça, ça a l’air simple, mais en pratique, ça donne quoi ? Eh bien, après environ trois semaines de galère en tout genre, principalement due à des problèmes de nombres flottants, de calcul de longueur de vecteurs et d’intersection entre les voxels, l’algorithme fonctionne !\nPour faire simple, les principaux problèmes que j’ai rencontrés pendant ces trois semaines et leurs solutions :\nQue se passe-t-il si l’on commence un Ray-Casting entre deux voxels sur un axe ? Et bien le voxel ayant la coordonnée la plus “grande” sera arbitrairement sélectionné. C’est un comportement qu’on veut à tout prix éviter, car cela veut dire qu’on n’est pas sûr dans cette situation de bien commencer là où l’on veut le ray-casting. J’ai donc ajouté une vérification pour détecter cette situation, et si elle est rencontrée, on va bien préciser que le prochain voxel se trouve à une distance de 0 et on va reculer notre position de 1 dans le sens inverse de notre vecteur de direction. On va aussi rajouter une distance minimale à un voxel pour ne pas coller nos boîtes de collisions à ces derniers.\nUn autre souci que j’ai rencontré est une erreur basique de calcul de longueur d’un vecteur. En fait, j’estimais mal la distance parcourue pendant un Ray-Casting, ce qui entraînait des situations où je ne détectais pas de collisions et me retrouvais avec des coordonnées à l’intérieur de voxels, chose que je ne pouvais pas ensuite gérer. Mon erreur était que j’additionnais mes déplacements sur tous les axes, et je considérais ensuite cette valeur comme la distance parcourue, sauf que cela ne fonctionne pas ainsi avec des vecteurs. Si j’avance de 1 en x et 1 en y, je n’aurai pas avancé de 2 mais d’environ 1,41… Donc pour calculer cela, rien de mieux que de stocker tous les déplacements sur les axes dans un vecteur et ensuite calculer la longueur de ce dernier pour obtenir la distance parcourue !\nEt voilà, avec tout ça, on dispose d’un algorithme de détection de collision entre nos entités et notre monde fonctionnel !\nVoici une vidéo démo du résultat :\nBonus Maintenant que le système de collision est implémenté, il est assez simple de rajouter un petit système de simulation de gravité et de saut ! Voici une petite démo de ce que ça donne :\nN’hésitez pas à me contacter si vous avez des questions / suggestions.\n",
  "wordCount" : "1516",
  "inLanguage": "en",
  "datePublished": "2023-08-08T14:53:43+02:00",
  "dateModified": "2023-08-08T14:53:43+02:00",
  "author":{
    "@type": "Person",
    "name": "Guillaume Magniadas"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://themagnat.github.io/blog/posts/mavoxel/collisions/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "DevBlog de Magnat",
    "logo": {
      "@type": "ImageObject",
      "url": "https://themagnat.github.io/blog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://themagnat.github.io/blog/" accesskey="h" title="DevBlog de Magnat (Alt + H)">DevBlog de Magnat</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://themagnat.github.io/blog/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://themagnat.github.io/blog/search/" title="Recherche">
                    <span>Recherche</span>
                </a>
            </li>
            <li>
                <a href="https://themagnat.github.io/blog/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://themagnat.github.io/" title="Site personnel">
                    <span>Site personnel</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://themagnat.github.io/blog/">Home</a>&nbsp;»&nbsp;<a href="https://themagnat.github.io/blog/posts/">Posts</a></div>
    <h1 class="post-title">
      Collisions
    </h1>
    <div class="post-meta"><span title='2023-08-08 14:53:43 +0200 CEST'>August 8, 2023</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Guillaume Magniadas&nbsp;|&nbsp;<a href="https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content/posts/Mavoxel/collisions.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduction" aria-label="Introduction">Introduction</a></li>
                <li>
                    <a href="#aabb" aria-label="AABB">AABB</a></li>
                <li>
                    <a href="#algorithme" aria-label="Algorithme">Algorithme</a></li>
                <li>
                    <a href="#ray-casting" aria-label="Ray-Casting">Ray-Casting</a></li>
                <li>
                    <a href="#bonus" aria-label="Bonus">Bonus</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<p>Cet article est un devlog parlant de l&rsquo;implémentation d&rsquo;un système de collision pour mon moteur de voxels Mavoxel.</p>
<p>Le principe d&rsquo;une collision est assez simple : si une entité est en mouvement, on va s&rsquo;assurer que la position d&rsquo;arrivée de cette dernière ne chevauche pas celle d&rsquo;un autre objet.</p>
<p>Bien sûr, ici nous somme dans un environnement 3D et nous traitons des volumes, donc il ne s&rsquo;agit pas simplement de vérifier la position d&rsquo;arrivée de l&rsquo;entité, mais l&rsquo;entièreté de l&rsquo;espace qu&rsquo;elle prend.</p>
<hr>
<h2 id="aabb">AABB<a hidden class="anchor" aria-hidden="true" href="#aabb">#</a></h2>
<p>Étant donné qu&rsquo;il existe une infinité de positions possibles dans un volume, nous allons simplifier la représentation de cet espace en utilisant une boîte alignée avec les axes, système de collision appelé &ldquo;AABB&rdquo; pour &ldquo;Axis Aligned Bounding Box&rdquo;. Il existe d&rsquo;autre représentation possible mais cette dernière nous convient particulièrement bien dans le cadre de notre moteur de voxels.</p>

<p
    
    align="center"
    
>
    <img src="/ressources/collisions/AABB_Types.png"
        
        
        
        
    >
</p>

<p>Avec ce système, chaque entité possèdera sa boite de collision &ldquo;AABB&rdquo; qui se déplacera en même temps qu&rsquo;elle, et pour vérifier les collisions avec les autres objets il suffira de vérifier leurs boite de collision entrent en intersection.</p>

<p
    
    align="center"
    
>
    <img src="/ressources/collisions/aabbtoaabb.png"
        
        
        
        
    >
</p>

<h2 id="algorithme">Algorithme<a hidden class="anchor" aria-hidden="true" href="#algorithme">#</a></h2>
<p>Super, ça paraît simple ! Mais il y a un problème : À quel moment devons-nous vérifier une possible collision ? Après un déplacement, vous me direz et je vous répondrais que oui, mais c&rsquo;est un peu plus compliqué que cela. Imaginez un objet qui se déplace sur un terrain fait de plusieurs cubes. Cet objet possède une vitesse de 2 en avant (comprenez qu&rsquo;il se déplace d&rsquo;une distance de 2 cubes en avant). Après le déplacement, il se retrouvera donc avancé de 2 cubes, et nous allons donc vérifier si il y a une collision sur son nouvel emplacement. Mais qu&rsquo;en est-il s&rsquo;il y avait un cube entre sa position de départ et celle d&rsquo;arrivée ?</p>
<p>Vous devez maintenant comprendre le problème. Bien sûr, dans la plupart des cas, aucun objet n&rsquo;est censé pouvoir se déplacer de 2 cubes en 1 frame, mais il existe plusieurs situations où cela peut arriver et qui sont mêmes assez connues dans l&rsquo;univers du Jeu vidéo, qui utilisent très souvent ce système de collision. Par exemple, si la machine du joueur freeze, l&rsquo;accumulation de temps écoulé entre 2 frames durant ce freeze va devenir très grande, et comme la plupart des jeux utilisent le temps entre les frames pour calculer la vitesse des déplacements (pour éviter qu&rsquo;un joueur avec plus de FPS puisse aller plus vite qu&rsquo;un joueur avec moins de FPS), il serait donc possible qu&rsquo;un gros freeze permette de donner une vélocité assez grande à un objet pour pouvoir ignorer des collisions sur son chemin. Ce problème étant très connu des développeurs de jeu vidéo, quelques fixes sont des fois mis en place pour éviter de telles situations, comme par exemple en donnant une borne maximale au temps écoulé entre 2 frames. Mais du coup avec un tel fix, un joueur qui freeze trop pourrait voir l&rsquo;horloge de son jeu se décaler lentement par rapport à une personne qui ne freeze pas, chose que l&rsquo;on veut éviter (nous voulons que chaque joueur se retrouve dans la même situation après les mêmes inputs, indépendamment de leurs machines).</p>
<p>Malheureusement, il n&rsquo;existe pas beaucoup de solutions documentées en ligne pour régler ce problème.</p>
<p>En effet, le système que je vous ai présenté au-dessus est en fait assez satisfaisant dans une très grande majorité des cas, et même pour mon projet en réalité ! Donc pourquoi m&rsquo;embêter ? En plus, cette solution a le bon goût d&rsquo;être très peu complexe pour la machine (je parle ici de complexité algorithmique).</p>
<p>Mais je n&rsquo;ai pas envie de me satisfaire d&rsquo;un système de collision que je trouve imparfait, c&rsquo;est pourquoi j&rsquo;ai décidé de chercher une solution !</p>
<p>Après pas mal de temps de réflexion, j&rsquo;ai commencé à penser à une idée : et si j&rsquo;utilisais le ray-casting ?</p>
<h2 id="ray-casting">Ray-Casting<a hidden class="anchor" aria-hidden="true" href="#ray-casting">#</a></h2>
<p>L&rsquo;idée derrière le ray-casting est assez simple : on part d&rsquo;une position et on tire un rayon dans une direction donnée et on s&rsquo;arrête lorsque notre rayon rencontre un obstacle.</p>

<p
    
    align="center"
    
>
    <img src="/ressources/collisions/raycast_exemple.png"
        
        
        
        
    >
</p>

<p>C&rsquo;est un algorithme qui est assez souvent utilisé pour faire de l&rsquo;affichage et calculer de manière assez précise si oui ou non un objet est visible pour l&rsquo;utilisateur. Cela est aussi utilisé pour voir si une surface est éclairée ou non par une source lumineuse.</p>
<p>Bref, ici l&rsquo;idée serait de s&rsquo;en servir pour savoir si oui ou non notre entité va rencontrer un autre objet.</p>
<p>Et cela tombe bien ! Il se trouve que j&rsquo;ai déjà implémenté un algorithme de Ray-casting pour mon moteur (code disponible ici) ! Actuellement, il ne me servait qu&rsquo;à déterminer les objets que l&rsquo;utilisateur pointe du regard (l&rsquo;objet au centre de son écran) et rien ne m&rsquo;empêche de le réutiliser dans mon autre cas de figure.</p>
<p>Problème : Le ray-casting est fait pour tirer un rayon partant d&rsquo;un point, pas d&rsquo;un volume (ici notre boîte de collision AABB). Il faut trouver une solution pour adapter l&rsquo;algorithme à un volume&hellip; Et bien pourquoi ne pas effectuer un ray-casting mais en partant de chacun des sommets de notre boîte de collision ?</p>
<p>C&rsquo;est donc ce que j&rsquo;ai décidé d&rsquo;implémenter ! Mais dans quel ordre ? Comment fait-on un ray-casting de plusieurs points en même temps ? Eh bien, l&rsquo;idée que j&rsquo;ai sélectionnée est d&rsquo;effectuer le ray-casting sur chacun des points de la boite de collision (8 points ici). On pourrait aussi optimiser cela en ne vérifiant que 7 points, car on sait qu&rsquo;il y en aura toujours un qui sera couvert par les 7 autres, mais c&rsquo;est un détail. Ensuite, on retient la collision la plus proche obtenue avec ces 8 ray-castings et on recommence en adaptant les entrées, c&rsquo;est-à-dire les positions de départ des ray-castings et la direction :</p>
<ul>
<li>Position de départ : On ajoute le déplacement effectué jusqu&rsquo;à la collision à toutes les positions.</li>
<li>Direction : On ajoute le déplacement effectué jusqu&rsquo;à la collision et on met à 0 la direction dans laquelle on a rencontré la collision.</li>
</ul>
<p>Et étant donné que nous sommes en 3D et que nous avons &ldquo;seulement&rdquo; 3 axes maximum avec lesquels nous pouvons rencontrer une collision avant que notre direction ne devienne un vecteur nul, on sait que nous n&rsquo;allons répéter cet algorithme que 3 fois dans le pire des cas.</p>
<p>Nous allons à chaque collision sauvegarder le déplacement effectué jusqu&rsquo;à la collision, et cet algorithme retournera donc la somme de tous ces déplacements avec le vecteur direction restant (s&rsquo;il n&rsquo;est pas nul).</p>
<p>Voici un petit schéma pour que vous puissiez essayer de visualiser l&rsquo;algorithme :</p>

<p
    
    align="center"
    
>
    <img src="/ressources/collisions/collision_schem.png"
        
        
        
        
    >
</p>

<p>Ici, les cubes verts représentent notre environnement, le cube rouge représente notre boîte de collision et les flèches bleues représentent les ray-castings effectués !</p>
<p>Bon, dit comme ça, ça a l&rsquo;air simple, mais en pratique, ça donne quoi ? Eh bien, après environ trois semaines de galère en tout genre, principalement due à des problèmes de nombres flottants, de calcul de longueur de vecteurs et d&rsquo;intersection entre les voxels, l&rsquo;algorithme fonctionne !</p>
<p>Pour faire simple, les principaux problèmes que j&rsquo;ai rencontrés pendant ces trois semaines et leurs solutions :</p>
<ul>
<li>
<p>Que se passe-t-il si l&rsquo;on commence un Ray-Casting entre deux voxels sur un axe ? Et bien le voxel ayant la coordonnée la plus &ldquo;grande&rdquo; sera arbitrairement sélectionné. C&rsquo;est un comportement qu&rsquo;on veut à tout prix éviter, car cela veut dire qu&rsquo;on n&rsquo;est pas sûr dans cette situation de bien commencer là où l&rsquo;on veut le ray-casting. J&rsquo;ai donc ajouté une vérification pour détecter cette situation, et si elle est rencontrée, on va bien préciser que le prochain voxel se trouve à une distance de 0 et on va reculer notre position de 1 dans le sens inverse de notre vecteur de direction. On va aussi rajouter une distance minimale à un voxel pour ne pas coller nos boîtes de collisions à ces derniers.</p>
</li>
<li>
<p>Un autre souci que j&rsquo;ai rencontré est une erreur basique de calcul de longueur d&rsquo;un vecteur. En fait, j&rsquo;estimais mal la distance parcourue pendant un Ray-Casting, ce qui entraînait des situations où je ne détectais pas de collisions et me retrouvais avec des coordonnées à l&rsquo;intérieur de voxels, chose que je ne pouvais pas ensuite gérer. Mon erreur était que j&rsquo;additionnais mes déplacements sur tous les axes, et je considérais ensuite cette valeur comme la distance parcourue, sauf que cela ne fonctionne pas ainsi avec des vecteurs. Si j&rsquo;avance de 1 en x et 1 en y, je n&rsquo;aurai pas avancé de 2 mais d&rsquo;environ 1,41&hellip; Donc pour calculer cela, rien de mieux que de stocker tous les déplacements sur les axes dans un vecteur et ensuite calculer la longueur de ce dernier pour obtenir la distance parcourue !</p>
</li>
</ul>
<p>Et voilà, avec tout ça, on dispose d&rsquo;un algorithme de détection de collision entre nos entités et notre monde fonctionnel !</p>
<p>Voici une vidéo démo du résultat :</p>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube-nocookie.com/embed/UnvhOSIVxfY" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<h2 id="bonus">Bonus<a hidden class="anchor" aria-hidden="true" href="#bonus">#</a></h2>
<p>Maintenant que le système de collision est implémenté, il est assez simple de rajouter un petit système de simulation de gravité et de saut ! Voici une petite démo de ce que ça donne :</p>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube-nocookie.com/embed/lMb-mrkqZjY" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<p>N’hésitez pas à me contacter si vous avez des questions / suggestions.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://themagnat.github.io/blog/tags/mavoxel/">Mavoxel</a></li>
      <li><a href="https://themagnat.github.io/blog/tags/ray-casting/">Ray-Casting</a></li>
    </ul>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Collisions on twitter"
        href="https://twitter.com/intent/tweet/?text=Collisions&amp;url=https%3a%2f%2fthemagnat.github.io%2fblog%2fposts%2fmavoxel%2fcollisions%2f&amp;hashtags=Mavoxel%2cRay-Casting">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Collisions on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fthemagnat.github.io%2fblog%2fposts%2fmavoxel%2fcollisions%2f&amp;title=Collisions&amp;summary=Collisions&amp;source=https%3a%2f%2fthemagnat.github.io%2fblog%2fposts%2fmavoxel%2fcollisions%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Collisions on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fthemagnat.github.io%2fblog%2fposts%2fmavoxel%2fcollisions%2f&title=Collisions">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Collisions on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fthemagnat.github.io%2fblog%2fposts%2fmavoxel%2fcollisions%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Collisions on whatsapp"
        href="https://api.whatsapp.com/send?text=Collisions%20-%20https%3a%2f%2fthemagnat.github.io%2fblog%2fposts%2fmavoxel%2fcollisions%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Collisions on telegram"
        href="https://telegram.me/share/url?text=Collisions&amp;url=https%3a%2f%2fthemagnat.github.io%2fblog%2fposts%2fmavoxel%2fcollisions%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://themagnat.github.io/blog/">DevBlog de Magnat</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
