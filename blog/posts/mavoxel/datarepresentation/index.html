<!DOCTYPE html>
<html lang="fr" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Mavoxel - Repr√©sentations en m√©moire d&#39;un monde de Voxels | DevBlog de Magnat</title>
<meta name="keywords" content="Mavoxel, Data structures, Ray-Tracing">
<meta name="description" content="Quelle structure de donn√©es est la plus adapt√©e pour repr√©senter un monde fait de Voxels ? Je vous parle de mon choix de structure de donn√©es pour Mavoxel.">
<meta name="author" content="Guillaume Magniadas">
<link rel="canonical" href="https://themagnat.github.io/blog/posts/mavoxel/datarepresentation/">
<link crossorigin="anonymous" href="/blog/assets/css/stylesheet.bf5f9f73cf17311d52cedbcda82c922e91b2f566d88a85ad9f5b5a08b586bd5f.css" integrity="" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/blog/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity=""
    onload="hljs.initHighlightingOnLoad();"></script>


<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[','\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});
</script>
<link rel="icon" href="https://themagnat.github.io/blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://themagnat.github.io/blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://themagnat.github.io/blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://themagnat.github.io/blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://themagnat.github.io/blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Mavoxel - Repr√©sentations en m√©moire d&#39;un monde de Voxels" />
<meta property="og:description" content="Quelle structure de donn√©es est la plus adapt√©e pour repr√©senter un monde fait de Voxels ? Je vous parle de mon choix de structure de donn√©es pour Mavoxel." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://themagnat.github.io/blog/posts/mavoxel/datarepresentation/" /><meta property="og:image" content="https://themagnat.github.io/blog/majora.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-09T13:13:55+02:00" />
<meta property="article:modified_time" content="2023-08-09T13:13:55+02:00" />
<meta property="og:see_also" content="https://themagnat.github.io/blog/posts/mavoxel/collisions/" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://themagnat.github.io/blog/majora.png"/>

<meta name="twitter:title" content="Mavoxel - Repr√©sentations en m√©moire d&#39;un monde de Voxels"/>
<meta name="twitter:description" content="Quelle structure de donn√©es est la plus adapt√©e pour repr√©senter un monde fait de Voxels ? Je vous parle de mon choix de structure de donn√©es pour Mavoxel."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://themagnat.github.io/blog/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Mavoxel - Repr√©sentations en m√©moire d'un monde de Voxels",
      "item": "https://themagnat.github.io/blog/posts/mavoxel/datarepresentation/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Mavoxel - Repr√©sentations en m√©moire d'un monde de Voxels",
  "name": "Mavoxel - Repr√©sentations en m√©moire d\u0027un monde de Voxels",
  "description": "Quelle structure de donn√©es est la plus adapt√©e pour repr√©senter un monde fait de Voxels ? Je vous parle de mon choix de structure de donn√©es pour Mavoxel.",
  "keywords": [
    "Mavoxel", "Data structures", "Ray-Tracing"
  ],
  "articleBody": "Introduction Cet article est un devlog parlant du choix d‚Äôune structure de donn√©es üìö pour repr√©senter un monde dans mon moteur de voxels Mavoxel üé≤.\nLors du d√©veloppement d‚Äôun projet informatique, on se retrouve tr√®s souvent (m√™me toujours) √† manipuler une grande quantit√© de donn√©es. Choisir la fa√ßon dont on va les stocker est donc une √©tape importante et risquera d‚Äôavoir un fort impact dans la suite des d√©veloppements. Si dans la plus part des langages haut niveau ce choix se r√©sume √† choir entre une list ou une map, en C++ ce choix n‚Äôest pas aussi simple. Une list assure la validit√© des r√©f√©rences sur ses objets m√™me apr√®s insertion mais ne permet par d‚Äôacc√©der √† n‚Äôimporte quel √©l√©ment en temps constant et son parcours demande un peu plus de temps qu‚Äôune structure de donn√©e contigu√´ en m√©moire comme un vector.\nIci dans le cadre d‚Äôun moteur de jeux, quand il va s‚Äôagir de donn√©es √† envoyer √† notre carte graphique, nous allons quasiment exclusivement utiliser des structures contigu√´ en m√©moire, donc le vector de la libraire standard du C++.\nRepr√©sentation d‚Äôun monde de Voxels Cela √©tant dit, repr√©senter l‚Äôenti√®ret√© de notre monde fait de Voxels dans un seul vector serait un petit peu na√Øf, car cela impliquerait de devoir choisir entre ces deux sc√©narios :\nGarder l‚Äôenti√®ret√© de nos Voxels charg√©s √† chaque instant peut importe l‚Äôemplacement du joueur. Ou\nDevoir effectuer des suppression et des insertions en continue dans notre vector en fonction de l‚Äôemplacement du joueur pour supprimer les Voxels trop √©loign√© et ins√©rer les Voxels entrant dans la port√©e du joueur. Le premier sc√©nario risque de vite √™tre limit√© √† mesure que le monde du joueur grandit et le second sc√©nario risque de poser de gros soucis de performances √©tant donn√© que nous travaillons sur un vector qui utilise une m√©moire contigu√´ et que supprimer ou ins√©rer des donn√©es sur ce type de m√©moire peut √™tre co√ªteux (r√©allocation, d√©placement des objets d√©j√† ins√©r√©‚Ä¶).\nBon de toute fa√ßon vous l‚Äôaurez s√ªrement d√©j√† devin√© et cette petite introduction √©tait s√ªrement inutile, mais dans ce type de moteur, le monde est g√©n√©ralement d√©coup√© en ce que l‚Äôon appelle des Chunks, et c‚Äôest donc l‚Äôapproche que j‚Äôai aussi d√©cid√© de suivre.\nChunks L‚Äôid√©e ici est de diviser notre monde en un ensemble de volume d‚Äôune m√™me taille que nous allons nommer des ‚ÄúChunks‚Äù.\nSur cette image, vous pouvez imaginer le grand cube comme √©tant notre monde et chaque petit cube comme un Chunk.\nCe d√©coupage √† plusieurs gros avantages :\nNe pas avoir √† g√©rer une √©norme structure de donn√©es mais plusieurs plus petites. Charger et d√©charger facilement et rapidement un ensemble de voxels en fonction de leurs positions par rapport au joueur. Pouvoir parall√©liser des op√©rations comme la g√©n√©ration / le chargements des Chunks. Pouvoir r√©duire l‚Äôespace de recherche quand on effectue une op√©ration comme un calcul de collision. On sait qu‚Äôon n‚Äôa besoins d‚Äôexaminer qu‚Äôun seul Chunk et a la limite ses voisins. Bien-s√ªr, il y a quand m√™me un inconv√©nient, l‚Äôacc√®s aux voisins d‚Äôun voxel n‚Äôest pas aussi trivial qu‚Äôavec une seule et unique structure de donn√©es. En effet, il faut faire quelques v√©rifications, comme s‚Äôassurer qu‚Äôon ne sort pas des limites du Chunk, auquel cas il faudra acc√©der aux donn√©es du Chunk voisin pour r√©cup√©rer le voxel convoit√©.\nMais je pense que vous en conviendrez avec moi, ce petit inconv√©nient et compl√®tement √©clips√© par tout les avantages que nous offre cette repr√©sentation de notre monde.\nBon, nous allons donc d√©couper notre monde en un nombre infini de position enti√®re dans nos 3 axes x, y et z et attribuer √† chacune de ces positions un Chunk, que nous g√©n√©rons et afficherons lorsque le joueur sera assez proche, et lorsque ce dernier s‚Äô√©loignera trop nous n‚Äôaurons plus qu‚Äôa ne plus afficher ce Chunk, voir le d√©charger de la m√©moire üòÄ !\nNous allons aussi devoir d√©finir la taille d‚Äôun Chunk. C‚Äôest √† dire, le nombre de voxels qu‚Äôil poss√©dera sur chacun de ses axes. Par exemple, il peut poss√©der 64 voxels de longueur, 64 voxels de largeur ainsi que 64 voxels de profondeur pour avoir des Chunks carr√©s. Avec une telle taille, chaque Chunk pourra contenir 64 * 64 * 64 = 262144 voxels ! Il serait aussi possible d‚Äôutiliser une taille diff√©rent pour un des axe comme l‚Äôaxe y, ce qui est par exemple fait dans Minecraft.\nIci j‚Äôai d√©cid√© d‚Äôutiliser une taille uniforme pour chaque axe, car j‚Äôaimerais accorder une certaine importance √† la verticalit√© dans mon moteur et donc ne pas limiter l‚Äôaxe y.\nTout cela √©tant dit, nous allons maintenant pouvoir commencer √† impl√©menter notre Chunk en C++ !\nstruct Chunk { int x, y, z; // La position du chunk dans le monde int size; // La taille du chunk sur chaque axe QuelqueChose voxels; // ..? les voxels ? }; Bon, vous l‚Äôaviez sans doute d√©j√† remarqu√© avant, mais je n‚Äôai toujours pas abord√© le stockage des voxels, et ce type de donn√©es ‚ÄúQuelqueChose‚Äù n‚Äôest d√©finitivement pas un type natif du C++ üôÉ.\nEn effet, m√™me si pendant l‚Äôintroduction j‚Äôai mentionn√© la possibilit√© d‚Äôutiliser un vector pour stocker les voxels, ce n‚Äôest pas la seule possibilit√© et nous allons m√™me rapidement voir qu‚Äôelle est loin d‚Äô√™tre optimale !\nStockage des Voxels Avant d‚Äôavancer, essayons de savoir ce que repr√©sente r√©ellement un voxel et ce que nous allons vouloir repr√©senter dans notre m√©moire.\nOn peut voir un voxel comme un simple cube. Dans notre monde et donc dans nos Chunks, chaque voxel est de la m√™me taille et poss√®de sa propre position. Sur une position donn√©e, un voxel prendra l‚Äôenti√®ret√© de l‚Äôespace jusqu‚Äôaux limites de sa positions (donc jusqu‚Äôaux voxels voisins).\nVoil√†, donc avec simplement une position, on peut repr√©senter un voxel ! Bon, on aimerait aussi pouvoir donne un style √† chaque voxel pour √©viter de se retrouver avec des voxels tous identiques. Ici plusieurs possibilit√©s :\nStocker dans chaque voxel un Material (Un Material repr√©sente souvent un ensemble de couleur d√©finissant comment un objet devra r√©agir √† la lumi√®re). Stocker un identifiant d√©finissant le type de surface que repr√©sente le voxel (Chaque identifiant √©tant donc reli√© √† un Material). Bien que la premi√®re approche permette une totale libert√© sur les possibilit√©s de surfaces pour les voxels (et ce m√™me de mani√®re dynamique), sur un terrain nous ne voulons de toute fa√ßon pas permettre un nombre infini de type de surfaces.\nLa seconde approche a l‚Äôavantage d‚Äô√™tre BEAUCOUP moins co√ªteuse en place, l√† ou la premi√®re n√©cessiterais de stocker au moins 3 couleurs et un flottant pour chaque voxels (donc 3 * 3 + 1 = 10 flottants par voxel), la seconde approche permet de ne stocker que un entier pour chaque voxel.\nDonc pour r√©sumer, voici √† quoi devrait ressembler une structure Voxel :\nstruct Voxel { int x, y, z; // Position dans le chunk int id; // L'identifiant du voxel }; Maintenant, voyons comment nous allons pouvoir stocker nos voxels dans nos Chunks !\nLe simple Vector Bon, on en parle depuis l‚Äôintroduction donc vous avez du le voir venir, mais la premi√®re approche, la plus simple mais aussi la plus na√Øve de toutes ü§™, stockers les voxels de notre Chunk dans un vector !\nIl nous suffit donc de cr√©er un vector de Voxel :\nvector\u003cVoxel\u003e data; Cette approche poss√®de plusieurs probl√®mes majeurs. Premi√®rement, on ne tire aucunement partie de la forme particuli√®re de notre Chunk qui est un volume cubique pour les informations de positions. Mais surtout, v√©rifier la pr√©sence d‚Äôun voxel sur une position pr√©cise au sein d‚Äôun Chunk est extr√™mement co√ªteux car il n‚Äôy a pas d‚Äôautres moyens que de parcourir le vector entier et tester les positions de tous les voxels. Cette op√©ration risquant d‚Äô√™tre tr√®s courante dans notre moteur (Calculs de collisions, s√©lection, occlusion ambiante‚Ä¶) nous allons √©viter cette mod√©lisation.\nLa Grille Comment tirer partie de la forme de notre Chunk qui est en fait un volume cubique ? Et bien en stockant nos voxels sous la forme d‚Äôune grille !\nL‚Äôavantage d‚Äôune telle structure de donn√©es est qu‚Äôil est possible de savoir la pr√©sence ou non d‚Äôun voxel sur une position dans notre Chunk instantan√©ment contrairement au simple vector !\narray\u003carray\u003carray\u003cint, 64\u003e, 64\u003e, 64\u003e data; ou\nint data[64][64][64]; La structure d‚Äôune grille permet donc de stocker l‚Äôinformation de la position naturellement via les index des donn√©s dans la grille, permettant ainsi de n‚Äôavoir √† stocker que l‚Äôidentifiants de nos voxel !\nIndex ? Pour les personnes qui ne sont pas famili√®res avec ce qu‚Äôest un ‚Äúindex‚Äù, il s‚Äôagit simplement du num√©ro d‚Äôun √©l√©ment dans nos donn√©es. Par exemple si je cr√©√© le tableau suivant :\nint mon_tableau[5] = [7, 5, 1, 6, 3]; Je peux dire que l‚Äô√©l√©ment 7 est √† l‚Äôindex 0 et l‚Äô√©l√©ment 6 est √† l‚Äôindex 3. Notez que dans la plus part des langages informatiques (et donc en C++), les index commencent √† 0.\nDans notre grille, on peut donc par exemple acc√©der √† l‚Äô√©l√©ment en position x = 14, z = 6 et z = 61 en faisant data[14][6][61]. L‚Äôacc√®s est donc en temps constant et la v√©rification de la pr√©sence ou non d‚Äôun voxel sur une certaine position dans nos Chunks est quasiment instantan√© (notez qu‚Äôon conservera l‚Äôidentifiant de voxel 0 comme repr√©sentant le vide), ce qui est un √©norme avantage par rapport au simple vector.\nMalheureusement, √ßa ne peut pas √™tre aussi simple, il y a deux soucis avec cette repr√©sentation :\nL‚Äôespace : Cette repr√©sentation n√©cessite de devoir initialiser l‚Äôenti√®ret√© des voxels possible dans notre Chunk, for√ßant un Chunk vide √† prendre autant de place en m√©moire qu‚Äôun Chunk remplie (m√™me si l‚Äôespace est vide, ces positions seront occup√© par des identifiants 0 repr√©sentant donc ce vide). L‚Äôacc√®s : Et l√† vous allez me dire : ‚ÄúMais je pensais que l‚Äôacc√®s √©tait justement le point fort des grilles ?‚Äù. Alors oui‚Ä¶ mais aussi non. En effet, acc√©der √† l‚Äôinformation ‚Äúexiste-t-il un voxel sur cette position ?‚Äù est tr√®s rapide, mais acc√©der √† la totalit√© des voxels est plus compliqu√©. Il faut pour cela parcourir l‚Äôint√©gralit√© de la grille et v√©rifier tout les √©l√©ments qui ne sont pas √©gale √† 0. On remarquera que ces deux soucis ne sont pas pr√©sent avec la repr√©sentation dans un simple vector. Particuli√®rement le second, qui risque de ralentir la creation des donn√©es d‚Äôaffichage √† envoyer √† la carte graphique si on imagine un syst√®me de rendu traditionnelle avec donc la creation d‚Äôune ‚Äúmesh‚Äù (Pas besoins de s‚Äôattarder sur ce terme ici, il faut juste noter qu‚Äôon aimerais simplement pouvoir r√©cup√©rer tous les voxels existant sans devoir parcourir tout les espaces vide de notre grille).\nGrille + Vector ü•∞ Pour r√©sumer, on aime la grille pour son acc√®s en temps contant √† un voxel en fonction de sa position, et on aime le vector pour le parcours de tout les voxels rapide. Et si on combinais ces deux structures ?\nvector\u003cVoxel\u003e data; int posToIndex[64][64][64]; L‚Äôid√©e ici va √™tre d‚Äôavoir notre grille qui va venir stocker l‚Äôindex des voxels plac√©s et toujours notre vector pour stocker tous nos voxels de fa√ßon contigu√´ !\nOn peut donc imaginer utiliser ces deux structures comme ceci :\nPour ins√©rer un nouveau voxel :\nposToIndex[voxel.x][voxel.y][voxel.z] = data.size(); data.push_back(voxel); // push_back permet d'ins√©rer un nouvel √©l√©ment Pour r√©cup√©rer un voxel en fonction de sa position :\nint index = posToIndex[position.x][position.y][position.z]; Voxel voxel = data[index]; Voil√†, simple mais efficace ! Bien s√ªr, on garde toujours l‚Äôinconv√©nient de m√©moire de la grille, mais on va dire qu‚Äôon est pr√™t √† faire ce sacrifice pour b√©n√©ficier des avantages de nos deux structures de donn√©es !\nCe mode de stockage √©tait celui que j‚Äôutilisais sur le projet Mavoxel au d√©but et √©tait plut√¥t efficace pour la plus part des op√©rations dans un syst√®me de rendu classique, mais le projet √† r√©cemment √©volu√© vers un nouveau mode de rendu, le Ray-Tracing, apportant de nouvelles probl√©matiques.\nRay-Tracing et Structure de donn√©es Bon, sans rentrer dans trop de d√©tails technique (et puis je compte s√ªrement √©crire un article sur l‚Äôimpl√©mentation du Ray-Tracing dans Mavoxel qui d√©taillera un peu plus son fonctionnement), j‚Äôai fais le choix de convertir le moteur de rendu en passant d‚Äôun rendu ‚Äúclassique‚Äù √† un rendu en Ray-Tracing.\nRapidement, comment rend-t-on une sc√®ne avec des techniques de Ray-Tracing ? On va se center sur notre cam√©ra et on va tirer un ‚Äúrayon‚Äù tout droit pour chaque pixel de notre √©cran. Ce rayon doit parcourir notre scene jusqu‚Äôa rencontrer un obstacle ou bien atteindre une distance limite. La couleur qui sera alors affich√© √† l‚Äô√©cran d√©pendra de l‚Äôobjet touch√© !\nVoici un sch√©ma qui r√©sume assez bien ce fonctionnement :\nBon, pour afficher notre scene nous devons envoyer notre terrain √† notre carte graphique puis tester pour chaque pixel si nous rencontrons un voxel ou non.\nIci, le format grille se pr√™te beaucoup plus √† la t√¢che que le format simple vector. Avec un simple vector, nous devrions tester chaque voxel de notre terrain pour chacun des pixel de notre rendu. Un calcul beaucoup trop complexe bien que les cartes graphiques soit optimiser pour effectuer des calculs en parall√®les, on parle ici d‚Äôune centaine de millier voir de millions de voxels, et donc le m√™me nombre de tests.\nSans trop rentrer dans les d√©tails, en envoyant la grille √† notre carte graphique, nous pouvons appliqu√© un algorithme un peu plus intelligent pour effectuer le Ray-Tracing sur notre monde. Nous allons traverser la grille en avan√ßant dans la direction de la cam√©ra, voxel par voxel.\nVoici un petit sch√©ma expliquant rapidement l‚Äôid√©e derri√®re l‚Äôalgorithme :\nAvec un tel algorithme, on est capable d‚Äôatteindre des performance en Ray-Tracing acceptable, avec une distance d‚Äôaffichage d‚Äôenviron 256 voxels. Mais m√™me si c‚Äôest acceptable, cela reste assez faible. Nous devons trouver un moyen de repr√©senter nos donn√©es qui pourrait permettre d‚Äôacc√©l√©rer le Ray-Tracing.\nMaintenant, si je vous disais qu‚Äôil existe une repr√©sentation qui permet une telle prouesse mais qui en plus permet aussi de r√©duire l‚Äôespace occup√© par les voxels, vous me croiriez ?\nSparsed Voxel Octree Oula, c‚Äôest quoi ce nom barbare me direz vous ? Et bien √ßa les amis, c‚Äôest une structure de donn√©es super ing√©nieuse, qui va nous permettre de r√©duire drastiquement nos temps de calculs lors d‚Äôun Ray-Tracing mais aussi de r√©duire la m√©moire occup√© par nos voxels !\nUn Sparsed Voxel Octree (que l‚Äôon appellera dor√©navant SVO si √ßa ne vous d√©range pas üòâ) est une forme particuli√®re d‚ÄôOctree. Sans rentrer dans les d√©tails, un Octree est une structure de donn√©es permettant de diviser un espace en plusieurs sous espace, eux m√™me aussi diviser jusqu‚Äô√† ce que ces sous espace soit compl√®tement vide ou compl√®tement plein.\nUn Octree est donc assez g√©n√©ral et peut √™tre utilis√© pour repr√©senter l‚Äôoccupation d‚Äôun espace par diff√©rents types d‚Äôobjets. Mais ici nous allons nous int√©resser √† sa variante, le SVO, qui comme son nom l‚Äôindique sert √† repr√©senter l‚Äôoccupation d‚Äôun espace par des voxels.\nL‚Äôid√©e derri√®re cette structure de donn√©es est la suivante :\nOn choisit une taille pour notre SVO qui doit √™tre une puissance de 2 (Par exemple 64). On divise l‚Äôespace de notre SVO en 8 parts √©gales, s√©par√© au milieu des 3 axes (donc sur la coordonn√©e 32 dans notre exemple). Pour chacun des sous-espace cr√©√©, on v√©rifie si les voxels qu‚Äôil englobe sont tous du m√™me type (Comprendre ici qu‚Äôils ont tous le m√™me identifiant, 0 √©tant consid√©r√© comme du vide). Si c‚Äôest le cas, on peut s‚Äôarr√™ter ici, sinon on r√©p√®te l‚Äô√©tape 2 (Cette fois-ci sur la coordonn√©e 16, puis 8, 4 et 2). Apr√®s toutes ces √©tapes, on est assur√© que chaque sous-espace de notre SVO est enti√®rement compos√© du m√™me type de voxel ou de vide. Bon, √ßa fais beaucoup, donc rien de mieux qu‚Äôun petit sch√©ma pour r√©sumer tout √ßa !\nEt un petit sch√©ma pour imager le passage d‚Äôune grille √† un SVO :\nJe pense que vous pouvez assez clairement voir en quoi cette repr√©sentation permet de gagner de la m√©moire, mais par-contre, en quoi va-t-elle nous aider pour notre Ray-Tracing ? Et bien, si on reprend notre pr√©c√©dent algorithme qui nous faisais parcourir les voxels de notre grille en suivant la direction de notre cam√©ra, on peut faire la m√™me chose ici mais en sautant directement les portions vide. On peut d√©j√† imaginer une grille qui √©tait totalement vide mais qui prenait quand m√™me 64 it√©ration pour √™tre parcouru par notre algorithme de Ray-Tracing sur sa longueur, l√† o√π avec notre SVO et notre version adapt√© de notre algorithme, cela ne prendra plus que 4 it√©rations !\nVoici un petit sch√©ma pour mieux visualiser la logique derri√®re ce nouvel algorithme :\nIl y a quand m√™me toujours deux inconv√©nients :\nToujours l‚Äôacc√®s : Et oui, comme pour la grille, r√©cup√©rer la liste compl√®te des voxels pr√©sent dans notre Chunk sans avoir de vector est une t√¢che co√ªteuse ! Mais √©tant donn√© que nous allons remplacer notre mode de rendu classique par le rendu en Ray-Tracing, nous n‚Äôaurons plus vraiment besoins de r√©cup√©rer une telle liste. Plus lent pour r√©cup√©rer une position : Contrairement √† la grille qui permettait de r√©cup√©rer instantan√©ment un voxel en fonction d‚Äôune position, dans notre SVO cet op√©ration est l√©g√®rement plus co√ªteuse, cela reste beaucoup, beaucoup plus rapide qu‚Äôavec un simple vector et on pourra n√©gliger ce co√ªt, mais il est quand m√™me important de le mentionner. Mais malgr√© ces deux points, la structure de donn√©es SVO reste extr√™mement int√©ressante et nous permet d‚Äôobtenir les meilleurs performances en temps r√©el avec l‚Äôalgorithme de Ray-Tracing, tout en conservant une occupation de la m√©moire plus que raisonnable !\nMalheureusement et pour votre plus grande tristesse, je n‚Äôai pas de d√©monstration √† vous pr√©senter pour conclure cet article ü•∫. En effet il est assez difficile montrer l‚Äôimpl√©mentation d‚Äôune nouvelle structure de donn√©es, mais je vais promet que pour le prochain article sur le Ray-Tracing, vous pourrez voir √† l‚Äôoeuvre toute la puissance du SVO coupl√© avec un algorithme de Ray-Tracing !\nSi vous avez une remarque ou des questions, ou si vous √™tes int√©ress√© pour parler un peu plus de l‚Äôimpl√©mentation du SVO, n‚Äôh√©sitez pas √† me contacter, vous pouvez retrouver mon email sur mon site personnel en entrant la commande CONTACT !\n",
  "wordCount" : "3045",
  "inLanguage": "fr",
  "datePublished": "2023-08-09T13:13:55+02:00",
  "dateModified": "2023-08-09T13:13:55+02:00",
  "author":{
    "@type": "Person",
    "name": "Guillaume Magniadas"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://themagnat.github.io/blog/posts/mavoxel/datarepresentation/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "DevBlog de Magnat",
    "logo": {
      "@type": "ImageObject",
      "url": "https://themagnat.github.io/blog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://themagnat.github.io/blog/" accesskey="h" title="DevBlog de Magnat (Alt + H)">DevBlog de Magnat</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://themagnat.github.io/blog/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://themagnat.github.io/blog/search/" title="Recherche">
                    <span>Recherche</span>
                </a>
            </li>
            <li>
                <a href="https://themagnat.github.io/blog/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://themagnat.github.io/" title="Site personnel">
                    <span>Site personnel</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://themagnat.github.io/blog/">Accueil</a>&nbsp;¬ª&nbsp;<a href="https://themagnat.github.io/blog/posts/">Posts</a></div>
    <h1 class="post-title">
      Mavoxel - Repr√©sentations en m√©moire d&#39;un monde de Voxels
    </h1>
    <div class="post-meta"><span title='2023-08-09 13:13:55 +0200 CEST'>ao√ªt 9, 2023</span>&nbsp;¬∑&nbsp;15 min&nbsp;¬∑&nbsp;Guillaume Magniadas&nbsp;|&nbsp;<a href="https://github.com/TheMagnat/TheMagnat.github.io/tree/main/blogBuilder/content/posts/Mavoxel/dataRepresentation.md" rel="noopener noreferrer" target="_blank">Proposer un changement</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table des mati√®res</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduction" aria-label="Introduction">Introduction</a></li>
                <li>
                    <a href="#repr%c3%a9sentation-dun-monde-de-voxels" aria-label="Repr√©sentation d&amp;rsquo;un monde de Voxels">Repr√©sentation d&rsquo;un monde de Voxels</a></li>
                <li>
                    <a href="#chunks" aria-label="Chunks">Chunks</a></li>
                <li>
                    <a href="#stockage-des-voxels" aria-label="Stockage des Voxels">Stockage des Voxels</a><ul>
                        
                <li>
                    <a href="#le-simple-vector" aria-label="Le simple Vector">Le simple Vector</a></li>
                <li>
                    <a href="#la-grille" aria-label="La Grille">La Grille</a><ul>
                        
                <li>
                    <a href="#index-" aria-label="Index ?">Index ?</a></li></ul>
                </li>
                <li>
                    <a href="#grille--vector-" aria-label="Grille &#43; Vector ü•∞">Grille + Vector ü•∞</a></li></ul>
                </li>
                <li>
                    <a href="#ray-tracing-et-structure-de-donn%c3%a9es" aria-label="Ray-Tracing et Structure de donn√©es">Ray-Tracing et Structure de donn√©es</a><ul>
                        
                <li>
                    <a href="#sparsed-voxel-octree" aria-label="Sparsed Voxel Octree">Sparsed Voxel Octree</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<p>Cet article est un devlog parlant du choix d&rsquo;une structure de donn√©es üìö pour repr√©senter un monde dans mon moteur de voxels <strong>Mavoxel</strong> üé≤.</p>
<p>Lors du d√©veloppement d&rsquo;un projet informatique, on se retrouve tr√®s souvent (m√™me toujours) √† manipuler une grande quantit√© de donn√©es. Choisir la fa√ßon dont on va les stocker est donc une √©tape importante et risquera d&rsquo;avoir un fort impact dans la suite des d√©veloppements. Si dans la plus part des langages haut niveau ce choix se r√©sume √† choir entre une <code>list</code> ou une <code>map</code>, en <strong>C++</strong> ce choix n&rsquo;est pas aussi simple. Une <code>list</code> assure la validit√© des r√©f√©rences sur ses objets m√™me apr√®s insertion mais ne permet par d&rsquo;acc√©der √† n&rsquo;importe quel √©l√©ment en temps constant et son parcours demande un peu plus de temps qu&rsquo;une structure de donn√©e contigu√´ en m√©moire comme un <code>vector</code>.</p>
<p>Ici dans le cadre d&rsquo;un moteur de jeux, quand il va s&rsquo;agir de donn√©es √† envoyer √† notre carte graphique, nous allons quasiment exclusivement utiliser des structures contigu√´ en m√©moire, donc le <code>vector</code> de la libraire standard du <strong>C++</strong>.</p>
<hr>
<h2 id="repr√©sentation-dun-monde-de-voxels">Repr√©sentation d&rsquo;un monde de Voxels<a hidden class="anchor" aria-hidden="true" href="#repr√©sentation-dun-monde-de-voxels">#</a></h2>
<p>Cela √©tant dit, repr√©senter l&rsquo;enti√®ret√© de notre monde fait de Voxels dans un seul <code>vector</code> serait un petit peu na√Øf, car cela impliquerait de devoir choisir entre ces deux sc√©narios :</p>
<ul>
<li>Garder l‚Äôenti√®ret√© de nos Voxels charg√©s √† chaque instant peut importe l&rsquo;emplacement du joueur.</li>
</ul>
<p>Ou</p>
<ul>
<li>Devoir effectuer des suppression et des insertions en continue dans notre <code>vector</code> en fonction de l&rsquo;emplacement du joueur pour supprimer les Voxels trop √©loign√© et ins√©rer les Voxels entrant dans la port√©e du joueur.</li>
</ul>
<p>Le premier sc√©nario risque de vite √™tre limit√© √† mesure que le monde du joueur grandit et le second sc√©nario risque de poser de gros soucis de performances √©tant donn√© que nous travaillons sur un <code>vector</code> qui utilise une m√©moire contigu√´ et que supprimer ou ins√©rer des donn√©es sur ce type de m√©moire peut √™tre co√ªteux (r√©allocation, d√©placement des objets d√©j√† ins√©r√©&hellip;).</p>
<p>Bon de toute fa√ßon vous l&rsquo;aurez s√ªrement d√©j√† devin√© et cette petite introduction √©tait s√ªrement inutile, mais dans ce type de moteur, le monde est g√©n√©ralement d√©coup√© en ce que l&rsquo;on appelle des <strong>Chunks</strong>, et c&rsquo;est donc l&rsquo;approche que j&rsquo;ai aussi d√©cid√© de suivre.</p>
<h2 id="chunks">Chunks<a hidden class="anchor" aria-hidden="true" href="#chunks">#</a></h2>
<p>L&rsquo;id√©e ici est de diviser notre monde en un ensemble de volume d&rsquo;une m√™me taille que nous allons nommer des &ldquo;<strong>Chunks</strong>&rdquo;.</p>

<p
    
    align="center"
    
>
    <img src="chunks.png"
        
        
        
        
    >
</p>

<p>Sur cette image, vous pouvez imaginer le grand cube comme √©tant notre monde et chaque petit cube comme un <strong>Chunk</strong>.</p>
<p>Ce d√©coupage √† plusieurs gros avantages :</p>
<ul>
<li>Ne pas avoir √† g√©rer une √©norme structure de donn√©es mais plusieurs plus petites.</li>
<li>Charger et d√©charger facilement et rapidement un ensemble de voxels en fonction de leurs positions par rapport au joueur.</li>
<li>Pouvoir parall√©liser des op√©rations comme la g√©n√©ration / le chargements des <strong>Chunks</strong>.</li>
<li>Pouvoir r√©duire l&rsquo;espace de recherche quand on effectue une op√©ration comme un calcul de collision. On sait qu&rsquo;on n&rsquo;a besoins d&rsquo;examiner qu&rsquo;un seul <strong>Chunk</strong> et a la limite ses voisins.</li>
</ul>
<p>Bien-s√ªr, il y a quand m√™me un inconv√©nient, l&rsquo;acc√®s aux voisins d&rsquo;un voxel n&rsquo;est pas aussi trivial qu&rsquo;avec une seule et unique structure de donn√©es. En effet, il faut faire quelques v√©rifications, comme s&rsquo;assurer qu&rsquo;on ne sort pas des limites du <strong>Chunk</strong>, auquel cas il faudra acc√©der aux donn√©es du <strong>Chunk</strong> voisin pour r√©cup√©rer le voxel convoit√©.</p>
<p>Mais je pense que vous en conviendrez avec moi, ce petit inconv√©nient et compl√®tement √©clips√© par tout les avantages que nous offre cette repr√©sentation de notre monde.</p>
<p>Bon, nous allons donc d√©couper notre monde en un nombre infini de position enti√®re dans nos 3 axes <code>x</code>, <code>y</code> et <code>z</code> et attribuer √† chacune de ces positions un <strong>Chunk</strong>, que nous g√©n√©rons et afficherons lorsque le joueur sera assez proche, et lorsque ce dernier s&rsquo;√©loignera trop nous n&rsquo;aurons plus qu&rsquo;a ne plus afficher ce <strong>Chunk</strong>, voir le d√©charger de la m√©moire üòÄ !</p>
<p>Nous allons aussi devoir d√©finir la taille d&rsquo;un <strong>Chunk</strong>. C&rsquo;est √† dire, le nombre de voxels qu&rsquo;il poss√©dera sur chacun de ses axes. Par exemple, il peut poss√©der 64 voxels de longueur, 64 voxels de largeur ainsi que 64 voxels de profondeur pour avoir des <strong>Chunks</strong> carr√©s. Avec une telle taille, chaque <strong>Chunk</strong> pourra contenir <code>64 * 64 * 64 = 262144</code> voxels ! Il serait aussi possible d&rsquo;utiliser une taille diff√©rent pour un des axe comme l&rsquo;axe <code>y</code>, ce qui est par exemple fait dans <em>Minecraft</em>.</p>
<p>Ici j&rsquo;ai d√©cid√© d&rsquo;utiliser une taille uniforme pour chaque axe, car j&rsquo;aimerais accorder une certaine importance √† la verticalit√© dans mon moteur et donc ne pas limiter l&rsquo;axe <code>y</code>.</p>
<p>Tout cela √©tant dit, nous allons maintenant pouvoir commencer √† impl√©menter notre Chunk en <strong>C++</strong> !</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Chunk</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span> <span class="c1">// La position du chunk dans le monde
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span> <span class="c1">// La taille du chunk sur chaque axe
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">QuelqueChose</span> <span class="n">voxels</span><span class="p">;</span> <span class="c1">// ..? les voxels ?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>Bon, vous l&rsquo;aviez sans doute d√©j√† remarqu√© avant, mais je n&rsquo;ai toujours pas abord√© le stockage des voxels, et ce type de donn√©es &ldquo;QuelqueChose&rdquo; n&rsquo;est d√©finitivement pas un type natif du <strong>C++</strong> üôÉ.</p>
<p>En effet, m√™me si pendant l&rsquo;introduction j&rsquo;ai mentionn√© la possibilit√© d&rsquo;utiliser un <code>vector</code> pour stocker les voxels, ce n&rsquo;est pas la seule possibilit√© et nous allons m√™me rapidement voir qu&rsquo;elle est loin d&rsquo;√™tre optimale !</p>
<h2 id="stockage-des-voxels">Stockage des Voxels<a hidden class="anchor" aria-hidden="true" href="#stockage-des-voxels">#</a></h2>
<p>Avant d&rsquo;avancer, essayons de savoir ce que repr√©sente r√©ellement un voxel et ce que nous allons vouloir repr√©senter dans notre m√©moire.</p>
<p>On peut voir un voxel comme un simple cube. Dans notre monde et donc dans nos <strong>Chunks</strong>, chaque voxel est de la m√™me taille et poss√®de sa propre position. Sur une position donn√©e, un voxel prendra l&rsquo;enti√®ret√© de l&rsquo;espace jusqu&rsquo;aux limites de sa positions (donc jusqu&rsquo;aux voxels voisins).</p>
<p>Voil√†, donc avec simplement une position, on peut repr√©senter un voxel ! Bon, on aimerait aussi pouvoir donne un style √† chaque voxel pour √©viter de se retrouver avec des voxels tous identiques. Ici plusieurs possibilit√©s :</p>
<ul>
<li>Stocker dans chaque voxel un <code>Material</code> (Un <code>Material</code> repr√©sente souvent un ensemble de couleur d√©finissant comment un objet devra r√©agir √† la lumi√®re).</li>
<li>Stocker un identifiant d√©finissant le type de surface que repr√©sente le voxel (Chaque identifiant √©tant donc reli√© √† un <code>Material</code>).</li>
</ul>
<p>Bien que la premi√®re approche permette une totale libert√© sur les possibilit√©s de surfaces pour les voxels (et ce m√™me de mani√®re dynamique), sur un terrain nous ne voulons de toute fa√ßon pas permettre un nombre infini de type de surfaces.</p>
<p>La seconde approche a l&rsquo;avantage d&rsquo;√™tre <strong>BEAUCOUP</strong> moins co√ªteuse en place, l√† ou la premi√®re n√©cessiterais de stocker au moins 3 couleurs et un flottant pour chaque voxels (donc <code>3 * 3 + 1 = 10</code> flottants par voxel), la seconde approche permet de ne stocker que un entier pour chaque voxel.</p>
<p>Donc pour r√©sumer, voici √† quoi devrait ressembler une structure <code>Voxel</code> :</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Voxel</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span> <span class="c1">// Position dans le chunk
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">id</span><span class="p">;</span> <span class="c1">// L&#39;identifiant du voxel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>Maintenant, voyons comment nous allons pouvoir stocker nos voxels dans nos <strong>Chunks</strong> !</p>
<h3 id="le-simple-vector">Le simple Vector<a hidden class="anchor" aria-hidden="true" href="#le-simple-vector">#</a></h3>
<p>Bon, on en parle depuis l&rsquo;introduction donc vous avez du le voir venir, mais la premi√®re approche, la plus simple mais aussi la plus na√Øve de toutes ü§™, stockers les voxels de notre <strong>Chunk</strong> dans un <code>vector</code> !</p>
<p>Il nous suffit donc de cr√©er un <code>vector</code> de <code>Voxel</code> :</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Voxel</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span> 
</span></span></code></pre></div><p>Cette approche poss√®de plusieurs probl√®mes majeurs.
Premi√®rement, on ne tire aucunement partie de la forme particuli√®re de notre <strong>Chunk</strong> qui est un volume cubique pour les informations de positions.
Mais surtout, v√©rifier la pr√©sence d&rsquo;un voxel sur une position pr√©cise au sein d&rsquo;un <strong>Chunk</strong> est extr√™mement co√ªteux car il n&rsquo;y a pas d&rsquo;autres moyens que de parcourir le <code>vector</code> entier et tester les positions de tous les voxels. Cette op√©ration risquant d&rsquo;√™tre tr√®s courante dans notre moteur (Calculs de collisions, s√©lection, occlusion ambiante&hellip;) nous allons √©viter cette mod√©lisation.</p>
<h3 id="la-grille">La Grille<a hidden class="anchor" aria-hidden="true" href="#la-grille">#</a></h3>
<p>Comment tirer partie de la forme de notre <strong>Chunk</strong> qui est en fait un volume cubique ? Et bien en stockant nos voxels sous la forme d&rsquo;une grille !</p>
<p>L&rsquo;avantage d&rsquo;une telle structure de donn√©es est qu&rsquo;il est possible de savoir la pr√©sence ou non d&rsquo;un voxel sur une position dans notre <strong>Chunk</strong> instantan√©ment contrairement au simple <code>vector</code> !</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">array</span><span class="o">&lt;</span><span class="n">array</span><span class="o">&lt;</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">64</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">64</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">64</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
</span></span></code></pre></div><p>ou</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="mi">64</span><span class="p">][</span><span class="mi">64</span><span class="p">][</span><span class="mi">64</span><span class="p">];</span>
</span></span></code></pre></div><p>La structure d&rsquo;une grille permet donc de stocker l&rsquo;information de la position naturellement via les index des donn√©s dans la grille, permettant ainsi de n&rsquo;avoir √† stocker que l&rsquo;identifiants de nos voxel !</p>
<h4 id="index-">Index ?<a hidden class="anchor" aria-hidden="true" href="#index-">#</a></h4>
<p>Pour les personnes qui ne sont pas famili√®res avec ce qu&rsquo;est un &ldquo;index&rdquo;, il s&rsquo;agit simplement du num√©ro d&rsquo;un √©l√©ment dans nos donn√©es. Par exemple si je cr√©√© le tableau suivant :</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">mon_tableau</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
</span></span></code></pre></div><p>Je peux dire que l&rsquo;√©l√©ment <code>7</code> est √† l&rsquo;index <strong>0</strong> et l&rsquo;√©l√©ment <code>6</code> est √† l&rsquo;index <strong>3</strong>. Notez que dans la plus part des langages informatiques (et donc en <strong>C++</strong>), les index commencent √† <strong>0</strong>.</p>
<p>Dans notre grille, on peut donc par exemple acc√©der √† l&rsquo;√©l√©ment en position <code>x = 14</code>, <code>z = 6</code> et <code>z = 61</code> en faisant <code>data[14][6][61]</code>. L&rsquo;acc√®s est donc en temps constant et la v√©rification de la pr√©sence ou non d&rsquo;un voxel sur une certaine position dans nos <strong>Chunks</strong> est quasiment instantan√© (notez qu&rsquo;on conservera l&rsquo;identifiant de voxel <strong>0</strong> comme repr√©sentant le <strong>vide</strong>), ce qui est un √©norme avantage par rapport au simple <code>vector</code>.</p>
<p>Malheureusement, √ßa ne peut pas √™tre aussi simple, il y a deux soucis avec cette repr√©sentation :</p>
<ul>
<li><strong>L&rsquo;espace</strong> : Cette repr√©sentation n√©cessite de devoir initialiser l&rsquo;enti√®ret√© des voxels possible dans notre <strong>Chunk</strong>, for√ßant un <strong>Chunk</strong> vide √† prendre autant de place en m√©moire qu&rsquo;un <strong>Chunk</strong> remplie (m√™me si l&rsquo;espace est vide, ces positions seront occup√© par des identifiants <strong>0</strong> repr√©sentant donc ce vide).</li>
<li><strong>L&rsquo;acc√®s</strong> : Et l√† vous allez me dire : &ldquo;Mais je pensais que l&rsquo;acc√®s √©tait justement le point fort des grilles ?&rdquo;. Alors oui&hellip; mais aussi non. En effet, acc√©der √† l&rsquo;information &ldquo;existe-t-il un voxel sur cette position ?&rdquo; est tr√®s rapide, mais acc√©der √† la totalit√© des voxels est plus compliqu√©. Il faut pour cela parcourir l&rsquo;int√©gralit√© de la grille et v√©rifier tout les √©l√©ments qui ne sont pas √©gale √† <strong>0</strong>.</li>
</ul>
<p>On remarquera que ces deux soucis ne sont pas pr√©sent avec la repr√©sentation dans un simple <code>vector</code>. Particuli√®rement le second, qui risque de ralentir la creation des donn√©es d&rsquo;affichage √† envoyer √† la carte graphique si on imagine un syst√®me de rendu traditionnelle avec donc la creation d&rsquo;une &ldquo;mesh&rdquo; (Pas besoins de s&rsquo;attarder sur ce terme ici, il faut juste noter qu&rsquo;on aimerais simplement pouvoir r√©cup√©rer tous les voxels existant sans devoir parcourir tout les espaces vide de notre grille).</p>
<h3 id="grille--vector-">Grille + Vector ü•∞<a hidden class="anchor" aria-hidden="true" href="#grille--vector-">#</a></h3>
<p>Pour r√©sumer, on aime la grille pour son acc√®s en temps contant √† un voxel en fonction de sa position, et on aime le <code>vector</code> pour le parcours de tout les voxels rapide.
Et si on combinais ces deux structures ?</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Voxel</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">posToIndex</span><span class="p">[</span><span class="mi">64</span><span class="p">][</span><span class="mi">64</span><span class="p">][</span><span class="mi">64</span><span class="p">];</span>
</span></span></code></pre></div><p>L&rsquo;id√©e ici va √™tre d&rsquo;avoir notre grille qui va venir stocker l&rsquo;index des voxels plac√©s et toujours notre <code>vector</code> pour stocker tous nos voxels de fa√ßon contigu√´ !</p>
<p>On peut donc imaginer utiliser ces deux structures comme ceci :</p>
<ul>
<li>
<p>Pour ins√©rer un nouveau voxel :</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">posToIndex</span><span class="p">[</span><span class="n">voxel</span><span class="p">.</span><span class="n">x</span><span class="p">][</span><span class="n">voxel</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">voxel</span><span class="p">.</span><span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">voxel</span><span class="p">);</span> <span class="c1">// push_back permet d&#39;ins√©rer un nouvel √©l√©ment
</span></span></span></code></pre></div></li>
<li>
<p>Pour r√©cup√©rer un voxel en fonction de sa position :</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">posToIndex</span><span class="p">[</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">][</span><span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">position</span><span class="p">.</span><span class="n">z</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">Voxel</span> <span class="n">voxel</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
</span></span></code></pre></div></li>
</ul>
<p>Voil√†, simple mais efficace ! Bien s√ªr, on garde toujours l‚Äôinconv√©nient de m√©moire de la grille, mais on va dire qu&rsquo;on est pr√™t √† faire ce sacrifice pour b√©n√©ficier des avantages de nos deux structures de donn√©es !</p>
<p>Ce mode de stockage √©tait celui que j&rsquo;utilisais sur le projet <strong>Mavoxel</strong> au d√©but et √©tait plut√¥t efficace pour la plus part des op√©rations dans un syst√®me de rendu classique, mais le projet √† r√©cemment √©volu√© vers un nouveau mode de rendu, le <strong>Ray-Tracing</strong>, apportant de nouvelles probl√©matiques.</p>
<h2 id="ray-tracing-et-structure-de-donn√©es">Ray-Tracing et Structure de donn√©es<a hidden class="anchor" aria-hidden="true" href="#ray-tracing-et-structure-de-donn√©es">#</a></h2>
<p>Bon, sans rentrer dans trop de d√©tails technique (et puis je compte s√ªrement √©crire un article sur l&rsquo;impl√©mentation du <strong>Ray-Tracing</strong> dans <strong>Mavoxel</strong> qui d√©taillera un peu plus son fonctionnement), j&rsquo;ai fais le choix de convertir le moteur de rendu en passant d&rsquo;un rendu &ldquo;classique&rdquo; √† un rendu en <strong>Ray-Tracing</strong>.</p>
<p>Rapidement, comment rend-t-on une sc√®ne avec des techniques de <strong>Ray-Tracing</strong> ? On va se center sur notre cam√©ra et on va tirer un &ldquo;rayon&rdquo; tout droit pour chaque pixel de notre √©cran.
Ce rayon doit parcourir notre scene jusqu&rsquo;a rencontrer un obstacle ou bien atteindre une distance limite. La couleur qui sera alors affich√© √† l&rsquo;√©cran d√©pendra de l&rsquo;objet touch√© !</p>
<p>Voici un sch√©ma qui r√©sume assez bien ce fonctionnement :</p>

<p
    
    align="center"
    
>
    <img src="ray_trace_diagram.svg"
        
        
        
        
    >
</p>

<p>Bon, pour afficher notre scene nous devons envoyer notre terrain √† notre carte graphique puis tester pour chaque pixel si nous rencontrons un voxel ou non.</p>
<p>Ici, le format grille se pr√™te beaucoup plus √† la t√¢che que le format simple <code>vector</code>. Avec un simple <code>vector</code>, nous devrions tester chaque voxel de notre terrain pour chacun des pixel de notre rendu. Un calcul beaucoup trop complexe bien que les cartes graphiques soit optimiser pour effectuer des calculs en parall√®les, on parle ici d&rsquo;une centaine de millier voir de millions de voxels, et donc le m√™me nombre de tests.</p>
<p>Sans trop rentrer dans les d√©tails, en envoyant la grille √† notre carte graphique, nous pouvons appliqu√© un algorithme un peu plus intelligent pour effectuer le <strong>Ray-Tracing</strong> sur notre monde. Nous allons traverser la grille en avan√ßant dans la direction de la cam√©ra, voxel par voxel.</p>
<p>Voici un petit sch√©ma expliquant rapidement l&rsquo;id√©e derri√®re l&rsquo;algorithme :</p>

<p
    
    align="center"
    
>
    <img src="grid_ray.png"
        
        
        
        
    >
</p>

<p>Avec un tel algorithme, on est capable d&rsquo;atteindre des performance en <strong>Ray-Tracing</strong> acceptable, avec une distance d&rsquo;affichage d&rsquo;environ 256 voxels. Mais m√™me si c&rsquo;est acceptable, cela reste assez faible. Nous devons trouver un moyen de repr√©senter nos donn√©es qui pourrait permettre d&rsquo;acc√©l√©rer le <strong>Ray-Tracing</strong>.</p>
<p>Maintenant, si je vous disais qu&rsquo;il existe une repr√©sentation qui permet une telle prouesse mais qui en plus permet aussi de r√©duire l&rsquo;espace occup√© par les voxels, vous me croiriez ?</p>
<h3 id="sparsed-voxel-octree">Sparsed Voxel Octree<a hidden class="anchor" aria-hidden="true" href="#sparsed-voxel-octree">#</a></h3>
<p>Oula, c&rsquo;est quoi ce nom barbare me direz vous ? Et bien √ßa les amis, c&rsquo;est une structure de donn√©es super ing√©nieuse, qui va nous permettre de r√©duire drastiquement nos temps de calculs lors d&rsquo;un <strong>Ray-Tracing</strong> mais aussi de r√©duire la m√©moire occup√© par nos voxels !</p>
<p>Un <strong>Sparsed Voxel Octree</strong> (que l&rsquo;on appellera dor√©navant SVO si √ßa ne vous d√©range pas üòâ) est une forme particuli√®re d&rsquo;<strong>Octree</strong>. Sans rentrer dans les d√©tails, un <strong>Octree</strong> est une structure de donn√©es permettant de diviser un espace en plusieurs sous espace, eux m√™me aussi diviser jusqu&rsquo;√† ce que ces sous espace soit compl√®tement vide ou compl√®tement plein.</p>
<p>Un <strong>Octree</strong> est donc assez g√©n√©ral et peut √™tre utilis√© pour repr√©senter l&rsquo;occupation d&rsquo;un espace par diff√©rents types d&rsquo;objets. Mais ici nous allons nous int√©resser √† sa variante, le <strong>SVO</strong>, qui comme son nom l&rsquo;indique sert √† repr√©senter l&rsquo;occupation d&rsquo;un espace par des voxels.</p>
<p>L&rsquo;id√©e derri√®re cette structure de donn√©es est la suivante :</p>
<ul>
<li>On choisit une taille pour notre <strong>SVO</strong> qui doit √™tre une puissance de <strong>2</strong> (Par exemple <code>64</code>).</li>
<li>On divise l&rsquo;espace de notre <strong>SVO</strong> en 8 parts √©gales, s√©par√© au milieu des 3 axes (donc sur la coordonn√©e <code>32</code> dans notre exemple).</li>
<li>Pour chacun des sous-espace cr√©√©, on v√©rifie si les voxels qu&rsquo;il englobe sont tous du m√™me type (Comprendre ici qu&rsquo;ils ont tous le m√™me identifiant, 0 √©tant consid√©r√© comme du vide). Si c&rsquo;est le cas, on peut s&rsquo;arr√™ter ici, sinon on r√©p√®te l&rsquo;√©tape <strong>2</strong> (Cette fois-ci sur la coordonn√©e <code>16</code>, puis <code>8</code>, <code>4</code> et <code>2</code>).</li>
<li>Apr√®s toutes ces √©tapes, on est assur√© que chaque sous-espace de notre <strong>SVO</strong> est enti√®rement compos√© du m√™me type de voxel ou de vide.</li>
</ul>
<p>Bon, √ßa fais beaucoup, donc rien de mieux qu&rsquo;un petit sch√©ma pour r√©sumer tout √ßa !</p>

<p
    
    align="center"
    
>
    <img src="octree.png"
        
        
        
        
    >
</p>

<p>Et un petit sch√©ma pour imager le passage d&rsquo;une grille √† un <strong>SVO</strong> :</p>

<p
    
    align="center"
    
>
    <img src="grid_to_svo.png"
        
        
        
        
    >
</p>

<p>Je pense que vous pouvez assez clairement voir en quoi cette repr√©sentation permet de gagner de la m√©moire, mais par-contre, en quoi va-t-elle nous aider pour notre <strong>Ray-Tracing</strong> ? Et bien, si on reprend notre pr√©c√©dent algorithme qui nous faisais parcourir les voxels de notre grille en suivant la direction de notre cam√©ra, on peut faire la m√™me chose ici mais en sautant directement les portions vide. On peut d√©j√† imaginer une grille qui √©tait totalement vide mais qui prenait quand m√™me <strong>64</strong> it√©ration pour √™tre parcouru par notre algorithme de <strong>Ray-Tracing</strong> sur sa longueur, l√† o√π avec notre <strong>SVO</strong> et notre version adapt√© de notre algorithme, cela ne prendra plus que <strong>4</strong> it√©rations !</p>
<p>Voici un petit sch√©ma pour mieux visualiser la logique derri√®re ce nouvel algorithme :</p>

<p
    
    align="center"
    
>
    <img src="octree_ray.png"
        
        
        
        
    >
</p>

<p>Il y a quand m√™me toujours deux inconv√©nients :</p>
<ul>
<li><strong>Toujours l‚Äôacc√®s</strong> : Et oui, comme pour la grille, r√©cup√©rer la liste compl√®te des voxels pr√©sent dans notre <strong>Chunk</strong> sans avoir de <code>vector</code> est une t√¢che co√ªteuse ! Mais √©tant donn√© que nous allons remplacer notre mode de rendu classique par le rendu en <strong>Ray-Tracing</strong>, nous n&rsquo;aurons plus vraiment besoins de r√©cup√©rer une telle liste.</li>
<li><strong>Plus lent pour r√©cup√©rer une position</strong> : Contrairement √† la grille qui permettait de r√©cup√©rer instantan√©ment un voxel en fonction d&rsquo;une position, dans notre <strong>SVO</strong> cet op√©ration est l√©g√®rement plus co√ªteuse, cela reste beaucoup, beaucoup plus rapide qu&rsquo;avec un simple <code>vector</code> et on pourra n√©gliger ce co√ªt, mais il est quand m√™me important de le mentionner.</li>
</ul>
<p>Mais malgr√© ces deux points, la structure de donn√©es <strong>SVO</strong> reste extr√™mement int√©ressante et nous permet d&rsquo;obtenir les meilleurs performances en temps r√©el avec l&rsquo;algorithme de <strong>Ray-Tracing</strong>, tout en conservant une occupation de la m√©moire plus que raisonnable !</p>
<p>Malheureusement et pour votre plus grande tristesse, je n&rsquo;ai pas de d√©monstration √† vous pr√©senter pour conclure cet article ü•∫. En effet il est assez difficile montrer l&rsquo;impl√©mentation d&rsquo;une nouvelle structure de donn√©es, mais je vais promet que pour le prochain article sur le <strong>Ray-Tracing</strong>, vous pourrez voir √† l&rsquo;oeuvre toute la puissance du <strong>SVO</strong> coupl√© avec un algorithme de <strong>Ray-Tracing</strong> !</p>
<p>Si vous avez une remarque ou des questions, ou si vous √™tes int√©ress√© pour parler un peu plus de l&rsquo;impl√©mentation du <strong>SVO</strong>, n&rsquo;h√©sitez pas √† me contacter, vous pouvez retrouver mon email sur mon site personnel en entrant la commande <code>CONTACT</code> !</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://themagnat.github.io/blog/tags/mavoxel/">Mavoxel</a></li>
      <li><a href="https://themagnat.github.io/blog/tags/data-structures/">Data structures</a></li>
      <li><a href="https://themagnat.github.io/blog/tags/ray-tracing/">Ray-Tracing</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://themagnat.github.io/blog/posts/mavoxel/collisions/">
    <span class="title">Suivant ¬ª</span>
    <br>
    <span>Mavoxel - Developement d&#39;un syst√®me de Collision</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Mavoxel - Repr√©sentations en m√©moire d&#39;un monde de Voxels on twitter"
        href="https://twitter.com/intent/tweet/?text=Mavoxel%20-%20Repr%c3%a9sentations%20en%20m%c3%a9moire%20d%27un%20monde%20de%20Voxels&amp;url=https%3a%2f%2fthemagnat.github.io%2fblog%2fposts%2fmavoxel%2fdatarepresentation%2f&amp;hashtags=Mavoxel%2cDatastructures%2cRay-Tracing">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Mavoxel - Repr√©sentations en m√©moire d&#39;un monde de Voxels on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fthemagnat.github.io%2fblog%2fposts%2fmavoxel%2fdatarepresentation%2f&amp;title=Mavoxel%20-%20Repr%c3%a9sentations%20en%20m%c3%a9moire%20d%27un%20monde%20de%20Voxels&amp;summary=Mavoxel%20-%20Repr%c3%a9sentations%20en%20m%c3%a9moire%20d%27un%20monde%20de%20Voxels&amp;source=https%3a%2f%2fthemagnat.github.io%2fblog%2fposts%2fmavoxel%2fdatarepresentation%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Mavoxel - Repr√©sentations en m√©moire d&#39;un monde de Voxels on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fthemagnat.github.io%2fblog%2fposts%2fmavoxel%2fdatarepresentation%2f&title=Mavoxel%20-%20Repr%c3%a9sentations%20en%20m%c3%a9moire%20d%27un%20monde%20de%20Voxels">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Mavoxel - Repr√©sentations en m√©moire d&#39;un monde de Voxels on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fthemagnat.github.io%2fblog%2fposts%2fmavoxel%2fdatarepresentation%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Mavoxel - Repr√©sentations en m√©moire d&#39;un monde de Voxels on whatsapp"
        href="https://api.whatsapp.com/send?text=Mavoxel%20-%20Repr%c3%a9sentations%20en%20m%c3%a9moire%20d%27un%20monde%20de%20Voxels%20-%20https%3a%2f%2fthemagnat.github.io%2fblog%2fposts%2fmavoxel%2fdatarepresentation%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Mavoxel - Repr√©sentations en m√©moire d&#39;un monde de Voxels on telegram"
        href="https://telegram.me/share/url?text=Mavoxel%20-%20Repr%c3%a9sentations%20en%20m%c3%a9moire%20d%27un%20monde%20de%20Voxels&amp;url=https%3a%2f%2fthemagnat.github.io%2fblog%2fposts%2fmavoxel%2fdatarepresentation%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://themagnat.github.io/blog/">DevBlog de Magnat</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'Copier';

        function copyingDone() {
            copybutton.innerHTML = 'Copi√© !';
            setTimeout(() => {
                copybutton.innerHTML = 'Copier';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
