<!DOCTYPE html>
<html lang="fr" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Mavoxel - Représentations en mémoire d&#39;un monde de Voxels | DevBlog de Magnat</title>
<meta name="keywords" content="Mavoxel, Data structures, Ray-Tracing">
<meta name="description" content="Quelle structure de données est la plus adaptée pour représenter un monde fait de Voxels ? Je vous parle de mon choix de structure de données pour Mavoxel.">
<meta name="author" content="Guillaume Magniadas">
<link rel="canonical" href="https://themagnat.github.io/blog/posts/mavoxel/datarepresentation/">
<link crossorigin="anonymous" href="/blog/assets/css/stylesheet.bf5f9f73cf17311d52cedbcda82c922e91b2f566d88a85ad9f5b5a08b586bd5f.css" integrity="" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/blog/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity=""
    onload="hljs.initHighlightingOnLoad();"></script>


<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[','\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});
</script>
<link rel="icon" href="https://themagnat.github.io/blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://themagnat.github.io/blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://themagnat.github.io/blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://themagnat.github.io/blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://themagnat.github.io/blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Mavoxel - Représentations en mémoire d&#39;un monde de Voxels" />
<meta property="og:description" content="Quelle structure de données est la plus adaptée pour représenter un monde fait de Voxels ? Je vous parle de mon choix de structure de données pour Mavoxel." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://themagnat.github.io/blog/posts/mavoxel/datarepresentation/" /><meta property="og:image" content="https://themagnat.github.io/blog/majora.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-09T13:13:55+02:00" />
<meta property="article:modified_time" content="2023-08-09T13:13:55+02:00" />
<meta property="og:see_also" content="https://themagnat.github.io/blog/posts/mavoxel/collisions/" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://themagnat.github.io/blog/majora.png"/>

<meta name="twitter:title" content="Mavoxel - Représentations en mémoire d&#39;un monde de Voxels"/>
<meta name="twitter:description" content="Quelle structure de données est la plus adaptée pour représenter un monde fait de Voxels ? Je vous parle de mon choix de structure de données pour Mavoxel."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://themagnat.github.io/blog/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Mavoxel - Représentations en mémoire d'un monde de Voxels",
      "item": "https://themagnat.github.io/blog/posts/mavoxel/datarepresentation/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Mavoxel - Représentations en mémoire d'un monde de Voxels",
  "name": "Mavoxel - Représentations en mémoire d\u0027un monde de Voxels",
  "description": "Quelle structure de données est la plus adaptée pour représenter un monde fait de Voxels ? Je vous parle de mon choix de structure de données pour Mavoxel.",
  "keywords": [
    "Mavoxel", "Data structures", "Ray-Tracing"
  ],
  "articleBody": "Introduction Cet article est un devlog parlant du choix d’une structure de données 📚 pour représenter un monde dans mon moteur de voxels Mavoxel 🎲.\nLors du développement d’un projet informatique, on se retrouve très souvent (même toujours) à manipuler une grande quantité de données. Choisir la façon dont on va les stocker est donc une étape importante et risquera d’avoir un fort impact dans la suite des développements. Si dans la plus part des langages haut niveau ce choix se résume à choir entre une list ou une map, en C++ ce choix n’est pas aussi simple. Une list assure la validité des références sur ses objets même après insertion mais ne permet par d’accéder à n’importe quel élément en temps constant et son parcours demande un peu plus de temps qu’une structure de donnée contiguë en mémoire comme un vector.\nIci dans le cadre d’un moteur de jeux, quand il va s’agir de données à envoyer à notre carte graphique, nous allons quasiment exclusivement utiliser des structures contiguë en mémoire, donc le vector de la libraire standard du C++.\nReprésentation d’un monde de Voxels Cela étant dit, représenter l’entièreté de notre monde fait de Voxels dans un seul vector serait un petit peu naïf, car cela impliquerait de devoir choisir entre ces deux scénarios :\nGarder l’entièreté de nos Voxels chargés à chaque instant peut importe l’emplacement du joueur. Ou\nDevoir effectuer des suppression et des insertions en continue dans notre vector en fonction de l’emplacement du joueur pour supprimer les Voxels trop éloigné et insérer les Voxels entrant dans la portée du joueur. Le premier scénario risque de vite être limité à mesure que le monde du joueur grandit et le second scénario risque de poser de gros soucis de performances étant donné que nous travaillons sur un vector qui utilise une mémoire contiguë et que supprimer ou insérer des données sur ce type de mémoire peut être coûteux (réallocation, déplacement des objets déjà inséré…).\nBon de toute façon vous l’aurez sûrement déjà deviné et cette petite introduction était sûrement inutile, mais dans ce type de moteur, le monde est généralement découpé en ce que l’on appelle des Chunks, et c’est donc l’approche que j’ai aussi décidé de suivre.\nChunks L’idée ici est de diviser notre monde en un ensemble de volume d’une même taille que nous allons nommer des “Chunks”.\nSur cette image, vous pouvez imaginer le grand cube comme étant notre monde et chaque petit cube comme un Chunk.\nCe découpage à plusieurs gros avantages :\nNe pas avoir à gérer une énorme structure de données mais plusieurs plus petites. Charger et décharger facilement et rapidement un ensemble de voxels en fonction de leurs positions par rapport au joueur. Pouvoir paralléliser des opérations comme la génération / le chargements des Chunks. Pouvoir réduire l’espace de recherche quand on effectue une opération comme un calcul de collision. On sait qu’on n’a besoins d’examiner qu’un seul Chunk et a la limite ses voisins. Bien-sûr, il y a quand même un inconvénient, l’accès aux voisins d’un voxel n’est pas aussi trivial qu’avec une seule et unique structure de données. En effet, il faut faire quelques vérifications, comme s’assurer qu’on ne sort pas des limites du Chunk, auquel cas il faudra accéder aux données du Chunk voisin pour récupérer le voxel convoité.\nMais je pense que vous en conviendrez avec moi, ce petit inconvénient et complètement éclipsé par tout les avantages que nous offre cette représentation de notre monde.\nBon, nous allons donc découper notre monde en un nombre infini de position entière dans nos 3 axes x, y et z et attribuer à chacune de ces positions un Chunk, que nous générons et afficherons lorsque le joueur sera assez proche, et lorsque ce dernier s’éloignera trop nous n’aurons plus qu’a ne plus afficher ce Chunk, voir le décharger de la mémoire 😀 !\nNous allons aussi devoir définir la taille d’un Chunk. C’est à dire, le nombre de voxels qu’il possédera sur chacun de ses axes. Par exemple, il peut posséder 64 voxels de longueur, 64 voxels de largeur ainsi que 64 voxels de profondeur pour avoir des Chunks carrés. Avec une telle taille, chaque Chunk pourra contenir 64 * 64 * 64 = 262144 voxels ! Il serait aussi possible d’utiliser une taille différent pour un des axe comme l’axe y, ce qui est par exemple fait dans Minecraft.\nIci j’ai décidé d’utiliser une taille uniforme pour chaque axe, car j’aimerais accorder une certaine importance à la verticalité dans mon moteur et donc ne pas limiter l’axe y.\nTout cela étant dit, nous allons maintenant pouvoir commencer à implémenter notre Chunk en C++ !\nstruct Chunk { int x, y, z; // La position du chunk dans le monde int size; // La taille du chunk sur chaque axe QuelqueChose voxels; // ..? les voxels ? }; Bon, vous l’aviez sans doute déjà remarqué avant, mais je n’ai toujours pas abordé le stockage des voxels, et ce type de données “QuelqueChose” n’est définitivement pas un type natif du C++ 🙃.\nEn effet, même si pendant l’introduction j’ai mentionné la possibilité d’utiliser un vector pour stocker les voxels, ce n’est pas la seule possibilité et nous allons même rapidement voir qu’elle est loin d’être optimale !\nStockage des Voxels Avant d’avancer, essayons de savoir ce que représente réellement un voxel et ce que nous allons vouloir représenter dans notre mémoire.\nOn peut voir un voxel comme un simple cube. Dans notre monde et donc dans nos Chunks, chaque voxel est de la même taille et possède sa propre position. Sur une position donnée, un voxel prendra l’entièreté de l’espace jusqu’aux limites de sa positions (donc jusqu’aux voxels voisins).\nVoilà, donc avec simplement une position, on peut représenter un voxel ! Bon, on aimerait aussi pouvoir donne un style à chaque voxel pour éviter de se retrouver avec des voxels tous identiques. Ici plusieurs possibilités :\nStocker dans chaque voxel un Material (Un Material représente souvent un ensemble de couleur définissant comment un objet devra réagir à la lumière). Stocker un identifiant définissant le type de surface que représente le voxel (Chaque identifiant étant donc relié à un Material). Bien que la première approche permette une totale liberté sur les possibilités de surfaces pour les voxels (et ce même de manière dynamique), sur un terrain nous ne voulons de toute façon pas permettre un nombre infini de type de surfaces.\nLa seconde approche a l’avantage d’être BEAUCOUP moins coûteuse en place, là ou la première nécessiterais de stocker au moins 3 couleurs et un flottant pour chaque voxels (donc 3 * 3 + 1 = 10 flottants par voxel), la seconde approche permet de ne stocker que un entier pour chaque voxel.\nDonc pour résumer, voici à quoi devrait ressembler une structure Voxel :\nstruct Voxel { int x, y, z; // Position dans le chunk int id; // L'identifiant du voxel }; Maintenant, voyons comment nous allons pouvoir stocker nos voxels dans nos Chunks !\nLe simple Vector Bon, on en parle depuis l’introduction donc vous avez du le voir venir, mais la première approche, la plus simple mais aussi la plus naïve de toutes 🤪, stockers les voxels de notre Chunk dans un vector !\nIl nous suffit donc de créer un vector de Voxel :\nvector\u003cVoxel\u003e data; Cette approche possède plusieurs problèmes majeurs. Premièrement, on ne tire aucunement partie de la forme particulière de notre Chunk qui est un volume cubique pour les informations de positions. Mais surtout, vérifier la présence d’un voxel sur une position précise au sein d’un Chunk est extrêmement coûteux car il n’y a pas d’autres moyens que de parcourir le vector entier et tester les positions de tous les voxels. Cette opération risquant d’être très courante dans notre moteur (Calculs de collisions, sélection, occlusion ambiante…) nous allons éviter cette modélisation.\nLa Grille Comment tirer partie de la forme de notre Chunk qui est en fait un volume cubique ? Et bien en stockant nos voxels sous la forme d’une grille !\nL’avantage d’une telle structure de données est qu’il est possible de savoir la présence ou non d’un voxel sur une position dans notre Chunk instantanément contrairement au simple vector !\narray\u003carray\u003carray\u003cint, 64\u003e, 64\u003e, 64\u003e data; ou\nint data[64][64][64]; La structure d’une grille permet donc de stocker l’information de la position naturellement via les index des donnés dans la grille, permettant ainsi de n’avoir à stocker que l’identifiants de nos voxel !\nIndex ? Pour les personnes qui ne sont pas familières avec ce qu’est un “index”, il s’agit simplement du numéro d’un élément dans nos données. Par exemple si je créé le tableau suivant :\nint mon_tableau[5] = [7, 5, 1, 6, 3]; Je peux dire que l’élément 7 est à l’index 0 et l’élément 6 est à l’index 3. Notez que dans la plus part des langages informatiques (et donc en C++), les index commencent à 0.\nDans notre grille, on peut donc par exemple accéder à l’élément en position x = 14, z = 6 et z = 61 en faisant data[14][6][61]. L’accès est donc en temps constant et la vérification de la présence ou non d’un voxel sur une certaine position dans nos Chunks est quasiment instantané (notez qu’on conservera l’identifiant de voxel 0 comme représentant le vide), ce qui est un énorme avantage par rapport au simple vector.\nMalheureusement, ça ne peut pas être aussi simple, il y a deux soucis avec cette représentation :\nL’espace : Cette représentation nécessite de devoir initialiser l’entièreté des voxels possible dans notre Chunk, forçant un Chunk vide à prendre autant de place en mémoire qu’un Chunk remplie (même si l’espace est vide, ces positions seront occupé par des identifiants 0 représentant donc ce vide). L’accès : Et là vous allez me dire : “Mais je pensais que l’accès était justement le point fort des grilles ?”. Alors oui… mais aussi non. En effet, accéder à l’information “existe-t-il un voxel sur cette position ?” est très rapide, mais accéder à la totalité des voxels est plus compliqué. Il faut pour cela parcourir l’intégralité de la grille et vérifier tout les éléments qui ne sont pas égale à 0. On remarquera que ces deux soucis ne sont pas présent avec la représentation dans un simple vector. Particulièrement le second, qui risque de ralentir la creation des données d’affichage à envoyer à la carte graphique si on imagine un système de rendu traditionnelle avec donc la creation d’une “mesh” (Pas besoins de s’attarder sur ce terme ici, il faut juste noter qu’on aimerais simplement pouvoir récupérer tous les voxels existant sans devoir parcourir tout les espaces vide de notre grille).\nGrille + Vector 🥰 Pour résumer, on aime la grille pour son accès en temps contant à un voxel en fonction de sa position, et on aime le vector pour le parcours de tout les voxels rapide. Et si on combinais ces deux structures ?\nvector\u003cVoxel\u003e data; int posToIndex[64][64][64]; L’idée ici va être d’avoir notre grille qui va venir stocker l’index des voxels placés et toujours notre vector pour stocker tous nos voxels de façon contiguë !\nOn peut donc imaginer utiliser ces deux structures comme ceci :\nPour insérer un nouveau voxel :\nposToIndex[voxel.x][voxel.y][voxel.z] = data.size(); data.push_back(voxel); // push_back permet d'insérer un nouvel élément Pour récupérer un voxel en fonction de sa position :\nint index = posToIndex[position.x][position.y][position.z]; Voxel voxel = data[index]; Voilà, simple mais efficace ! Bien sûr, on garde toujours l’inconvénient de mémoire de la grille, mais on va dire qu’on est prêt à faire ce sacrifice pour bénéficier des avantages de nos deux structures de données !\nCe mode de stockage était celui que j’utilisais sur le projet Mavoxel au début et était plutôt efficace pour la plus part des opérations dans un système de rendu classique, mais le projet à récemment évolué vers un nouveau mode de rendu, le Ray-Tracing, apportant de nouvelles problématiques.\nRay-Tracing et Structure de données Bon, sans rentrer dans trop de détails technique (et puis je compte sûrement écrire un article sur l’implémentation du Ray-Tracing dans Mavoxel qui détaillera un peu plus son fonctionnement), j’ai fais le choix de convertir le moteur de rendu en passant d’un rendu “classique” à un rendu en Ray-Tracing.\nRapidement, comment rend-t-on une scène avec des techniques de Ray-Tracing ? On va se center sur notre caméra et on va tirer un “rayon” tout droit pour chaque pixel de notre écran. Ce rayon doit parcourir notre scene jusqu’a rencontrer un obstacle ou bien atteindre une distance limite. La couleur qui sera alors affiché à l’écran dépendra de l’objet touché !\nVoici un schéma qui résume assez bien ce fonctionnement :\nBon, pour afficher notre scene nous devons envoyer notre terrain à notre carte graphique puis tester pour chaque pixel si nous rencontrons un voxel ou non.\nIci, le format grille se prête beaucoup plus à la tâche que le format simple vector. Avec un simple vector, nous devrions tester chaque voxel de notre terrain pour chacun des pixel de notre rendu. Un calcul beaucoup trop complexe bien que les cartes graphiques soit optimiser pour effectuer des calculs en parallèles, on parle ici d’une centaine de millier voir de millions de voxels, et donc le même nombre de tests.\nSans trop rentrer dans les détails, en envoyant la grille à notre carte graphique, nous pouvons appliqué un algorithme un peu plus intelligent pour effectuer le Ray-Tracing sur notre monde. Nous allons traverser la grille en avançant dans la direction de la caméra, voxel par voxel.\nVoici un petit schéma expliquant rapidement l’idée derrière l’algorithme :\nAvec un tel algorithme, on est capable d’atteindre des performance en Ray-Tracing acceptable, avec une distance d’affichage d’environ 256 voxels. Mais même si c’est acceptable, cela reste assez faible. Nous devons trouver un moyen de représenter nos données qui pourrait permettre d’accélérer le Ray-Tracing.\nMaintenant, si je vous disais qu’il existe une représentation qui permet une telle prouesse mais qui en plus permet aussi de réduire l’espace occupé par les voxels, vous me croiriez ?\nSparsed Voxel Octree Oula, c’est quoi ce nom barbare me direz vous ? Et bien ça les amis, c’est une structure de données super ingénieuse, qui va nous permettre de réduire drastiquement nos temps de calculs lors d’un Ray-Tracing mais aussi de réduire la mémoire occupé par nos voxels !\nUn Sparsed Voxel Octree (que l’on appellera dorénavant SVO si ça ne vous dérange pas 😉) est une forme particulière d’Octree. Sans rentrer dans les détails, un Octree est une structure de données permettant de diviser un espace en plusieurs sous espace, eux même aussi diviser jusqu’à ce que ces sous espace soit complètement vide ou complètement plein.\nUn Octree est donc assez général et peut être utilisé pour représenter l’occupation d’un espace par différents types d’objets. Mais ici nous allons nous intéresser à sa variante, le SVO, qui comme son nom l’indique sert à représenter l’occupation d’un espace par des voxels.\nL’idée derrière cette structure de données est la suivante :\nOn choisit une taille pour notre SVO qui doit être une puissance de 2 (Par exemple 64). On divise l’espace de notre SVO en 8 parts égales, séparé au milieu des 3 axes (donc sur la coordonnée 32 dans notre exemple). Pour chacun des sous-espace créé, on vérifie si les voxels qu’il englobe sont tous du même type (Comprendre ici qu’ils ont tous le même identifiant, 0 étant considéré comme du vide). Si c’est le cas, on peut s’arrêter ici, sinon on répète l’étape 2 (Cette fois-ci sur la coordonnée 16, puis 8, 4 et 2). Après toutes ces étapes, on est assuré que chaque sous-espace de notre SVO est entièrement composé du même type de voxel ou de vide. Bon, ça fais beaucoup, donc rien de mieux qu’un petit schéma pour résumer tout ça !\nEt un petit schéma pour imager le passage d’une grille à un SVO :\nJe pense que vous pouvez assez clairement voir en quoi cette représentation permet de gagner de la mémoire, mais par-contre, en quoi va-t-elle nous aider pour notre Ray-Tracing ? Et bien, si on reprend notre précédent algorithme qui nous faisais parcourir les voxels de notre grille en suivant la direction de notre caméra, on peut faire la même chose ici mais en sautant directement les portions vide. On peut déjà imaginer une grille qui était totalement vide mais qui prenait quand même 64 itération pour être parcouru par notre algorithme de Ray-Tracing sur sa longueur, là où avec notre SVO et notre version adapté de notre algorithme, cela ne prendra plus que 4 itérations !\nVoici un petit schéma pour mieux visualiser la logique derrière ce nouvel algorithme :\nIl y a quand même toujours deux inconvénients :\nToujours l’accès : Et oui, comme pour la grille, récupérer la liste complète des voxels présent dans notre Chunk sans avoir de vector est une tâche coûteuse ! Mais étant donné que nous allons remplacer notre mode de rendu classique par le rendu en Ray-Tracing, nous n’aurons plus vraiment besoins de récupérer une telle liste. Plus lent pour récupérer une position : Contrairement à la grille qui permettait de récupérer instantanément un voxel en fonction d’une position, dans notre SVO cet opération est légèrement plus coûteuse, cela reste beaucoup, beaucoup plus rapide qu’avec un simple vector et on pourra négliger ce coût, mais il est quand même important de le mentionner. Mais malgré ces deux points, la structure de données SVO reste extrêmement intéressante et nous permet d’obtenir les meilleurs performances en temps réel avec l’algorithme de Ray-Tracing, tout en conservant une occupation de la mémoire plus que raisonnable !\nMalheureusement et pour votre plus grande tristesse, je n’ai pas de démonstration à vous présenter pour conclure cet article 🥺. En effet il est assez difficile montrer l’implémentation d’une nouvelle structure de données, mais je vais promet que pour le prochain article sur le Ray-Tracing, vous pourrez voir à l’oeuvre toute la puissance du SVO couplé avec un algorithme de Ray-Tracing !\nSi vous avez une remarque ou des questions, ou si vous êtes intéressé pour parler un peu plus de l’implémentation du SVO, n’hésitez pas à me contacter, vous pouvez retrouver mon email sur mon site personnel en entrant la commande CONTACT !\n",
  "wordCount" : "3045",
  "inLanguage": "fr",
  "datePublished": "2023-08-09T13:13:55+02:00",
  "dateModified": "2023-08-09T13:13:55+02:00",
  "author":{
    "@type": "Person",
    "name": "Guillaume Magniadas"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://themagnat.github.io/blog/posts/mavoxel/datarepresentation/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "DevBlog de Magnat",
    "logo": {
      "@type": "ImageObject",
      "url": "https://themagnat.github.io/blog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://themagnat.github.io/blog/" accesskey="h" title="DevBlog de Magnat (Alt + H)">DevBlog de Magnat</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://themagnat.github.io/blog/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://themagnat.github.io/blog/search/" title="Recherche">
                    <span>Recherche</span>
                </a>
            </li>
            <li>
                <a href="https://themagnat.github.io/blog/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://themagnat.github.io/" title="Site personnel">
                    <span>Site personnel</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://themagnat.github.io/blog/">Accueil</a>&nbsp;»&nbsp;<a href="https://themagnat.github.io/blog/posts/">Posts</a></div>
    <h1 class="post-title">
      Mavoxel - Représentations en mémoire d&#39;un monde de Voxels
    </h1>
    <div class="post-meta"><span title='2023-08-09 13:13:55 +0200 CEST'>août 9, 2023</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Guillaume Magniadas&nbsp;|&nbsp;<a href="https://github.com/TheMagnat/TheMagnat.github.io/tree/main/blogBuilder/content/posts/Mavoxel/dataRepresentation.md" rel="noopener noreferrer" target="_blank">Proposer un changement</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table des matières</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduction" aria-label="Introduction">Introduction</a></li>
                <li>
                    <a href="#repr%c3%a9sentation-dun-monde-de-voxels" aria-label="Représentation d&amp;rsquo;un monde de Voxels">Représentation d&rsquo;un monde de Voxels</a></li>
                <li>
                    <a href="#chunks" aria-label="Chunks">Chunks</a></li>
                <li>
                    <a href="#stockage-des-voxels" aria-label="Stockage des Voxels">Stockage des Voxels</a><ul>
                        
                <li>
                    <a href="#le-simple-vector" aria-label="Le simple Vector">Le simple Vector</a></li>
                <li>
                    <a href="#la-grille" aria-label="La Grille">La Grille</a><ul>
                        
                <li>
                    <a href="#index-" aria-label="Index ?">Index ?</a></li></ul>
                </li>
                <li>
                    <a href="#grille--vector-" aria-label="Grille &#43; Vector 🥰">Grille + Vector 🥰</a></li></ul>
                </li>
                <li>
                    <a href="#ray-tracing-et-structure-de-donn%c3%a9es" aria-label="Ray-Tracing et Structure de données">Ray-Tracing et Structure de données</a><ul>
                        
                <li>
                    <a href="#sparsed-voxel-octree" aria-label="Sparsed Voxel Octree">Sparsed Voxel Octree</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<p>Cet article est un devlog parlant du choix d&rsquo;une structure de données 📚 pour représenter un monde dans mon moteur de voxels <strong>Mavoxel</strong> 🎲.</p>
<p>Lors du développement d&rsquo;un projet informatique, on se retrouve très souvent (même toujours) à manipuler une grande quantité de données. Choisir la façon dont on va les stocker est donc une étape importante et risquera d&rsquo;avoir un fort impact dans la suite des développements. Si dans la plus part des langages haut niveau ce choix se résume à choir entre une <code>list</code> ou une <code>map</code>, en <strong>C++</strong> ce choix n&rsquo;est pas aussi simple. Une <code>list</code> assure la validité des références sur ses objets même après insertion mais ne permet par d&rsquo;accéder à n&rsquo;importe quel élément en temps constant et son parcours demande un peu plus de temps qu&rsquo;une structure de donnée contiguë en mémoire comme un <code>vector</code>.</p>
<p>Ici dans le cadre d&rsquo;un moteur de jeux, quand il va s&rsquo;agir de données à envoyer à notre carte graphique, nous allons quasiment exclusivement utiliser des structures contiguë en mémoire, donc le <code>vector</code> de la libraire standard du <strong>C++</strong>.</p>
<hr>
<h2 id="représentation-dun-monde-de-voxels">Représentation d&rsquo;un monde de Voxels<a hidden class="anchor" aria-hidden="true" href="#représentation-dun-monde-de-voxels">#</a></h2>
<p>Cela étant dit, représenter l&rsquo;entièreté de notre monde fait de Voxels dans un seul <code>vector</code> serait un petit peu naïf, car cela impliquerait de devoir choisir entre ces deux scénarios :</p>
<ul>
<li>Garder l’entièreté de nos Voxels chargés à chaque instant peut importe l&rsquo;emplacement du joueur.</li>
</ul>
<p>Ou</p>
<ul>
<li>Devoir effectuer des suppression et des insertions en continue dans notre <code>vector</code> en fonction de l&rsquo;emplacement du joueur pour supprimer les Voxels trop éloigné et insérer les Voxels entrant dans la portée du joueur.</li>
</ul>
<p>Le premier scénario risque de vite être limité à mesure que le monde du joueur grandit et le second scénario risque de poser de gros soucis de performances étant donné que nous travaillons sur un <code>vector</code> qui utilise une mémoire contiguë et que supprimer ou insérer des données sur ce type de mémoire peut être coûteux (réallocation, déplacement des objets déjà inséré&hellip;).</p>
<p>Bon de toute façon vous l&rsquo;aurez sûrement déjà deviné et cette petite introduction était sûrement inutile, mais dans ce type de moteur, le monde est généralement découpé en ce que l&rsquo;on appelle des <strong>Chunks</strong>, et c&rsquo;est donc l&rsquo;approche que j&rsquo;ai aussi décidé de suivre.</p>
<h2 id="chunks">Chunks<a hidden class="anchor" aria-hidden="true" href="#chunks">#</a></h2>
<p>L&rsquo;idée ici est de diviser notre monde en un ensemble de volume d&rsquo;une même taille que nous allons nommer des &ldquo;<strong>Chunks</strong>&rdquo;.</p>

<p
    
    align="center"
    
>
    <img src="chunks.png"
        
        
        
        
    >
</p>

<p>Sur cette image, vous pouvez imaginer le grand cube comme étant notre monde et chaque petit cube comme un <strong>Chunk</strong>.</p>
<p>Ce découpage à plusieurs gros avantages :</p>
<ul>
<li>Ne pas avoir à gérer une énorme structure de données mais plusieurs plus petites.</li>
<li>Charger et décharger facilement et rapidement un ensemble de voxels en fonction de leurs positions par rapport au joueur.</li>
<li>Pouvoir paralléliser des opérations comme la génération / le chargements des <strong>Chunks</strong>.</li>
<li>Pouvoir réduire l&rsquo;espace de recherche quand on effectue une opération comme un calcul de collision. On sait qu&rsquo;on n&rsquo;a besoins d&rsquo;examiner qu&rsquo;un seul <strong>Chunk</strong> et a la limite ses voisins.</li>
</ul>
<p>Bien-sûr, il y a quand même un inconvénient, l&rsquo;accès aux voisins d&rsquo;un voxel n&rsquo;est pas aussi trivial qu&rsquo;avec une seule et unique structure de données. En effet, il faut faire quelques vérifications, comme s&rsquo;assurer qu&rsquo;on ne sort pas des limites du <strong>Chunk</strong>, auquel cas il faudra accéder aux données du <strong>Chunk</strong> voisin pour récupérer le voxel convoité.</p>
<p>Mais je pense que vous en conviendrez avec moi, ce petit inconvénient et complètement éclipsé par tout les avantages que nous offre cette représentation de notre monde.</p>
<p>Bon, nous allons donc découper notre monde en un nombre infini de position entière dans nos 3 axes <code>x</code>, <code>y</code> et <code>z</code> et attribuer à chacune de ces positions un <strong>Chunk</strong>, que nous générons et afficherons lorsque le joueur sera assez proche, et lorsque ce dernier s&rsquo;éloignera trop nous n&rsquo;aurons plus qu&rsquo;a ne plus afficher ce <strong>Chunk</strong>, voir le décharger de la mémoire 😀 !</p>
<p>Nous allons aussi devoir définir la taille d&rsquo;un <strong>Chunk</strong>. C&rsquo;est à dire, le nombre de voxels qu&rsquo;il possédera sur chacun de ses axes. Par exemple, il peut posséder 64 voxels de longueur, 64 voxels de largeur ainsi que 64 voxels de profondeur pour avoir des <strong>Chunks</strong> carrés. Avec une telle taille, chaque <strong>Chunk</strong> pourra contenir <code>64 * 64 * 64 = 262144</code> voxels ! Il serait aussi possible d&rsquo;utiliser une taille différent pour un des axe comme l&rsquo;axe <code>y</code>, ce qui est par exemple fait dans <em>Minecraft</em>.</p>
<p>Ici j&rsquo;ai décidé d&rsquo;utiliser une taille uniforme pour chaque axe, car j&rsquo;aimerais accorder une certaine importance à la verticalité dans mon moteur et donc ne pas limiter l&rsquo;axe <code>y</code>.</p>
<p>Tout cela étant dit, nous allons maintenant pouvoir commencer à implémenter notre Chunk en <strong>C++</strong> !</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Chunk</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span> <span class="c1">// La position du chunk dans le monde
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span> <span class="c1">// La taille du chunk sur chaque axe
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">QuelqueChose</span> <span class="n">voxels</span><span class="p">;</span> <span class="c1">// ..? les voxels ?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>Bon, vous l&rsquo;aviez sans doute déjà remarqué avant, mais je n&rsquo;ai toujours pas abordé le stockage des voxels, et ce type de données &ldquo;QuelqueChose&rdquo; n&rsquo;est définitivement pas un type natif du <strong>C++</strong> 🙃.</p>
<p>En effet, même si pendant l&rsquo;introduction j&rsquo;ai mentionné la possibilité d&rsquo;utiliser un <code>vector</code> pour stocker les voxels, ce n&rsquo;est pas la seule possibilité et nous allons même rapidement voir qu&rsquo;elle est loin d&rsquo;être optimale !</p>
<h2 id="stockage-des-voxels">Stockage des Voxels<a hidden class="anchor" aria-hidden="true" href="#stockage-des-voxels">#</a></h2>
<p>Avant d&rsquo;avancer, essayons de savoir ce que représente réellement un voxel et ce que nous allons vouloir représenter dans notre mémoire.</p>
<p>On peut voir un voxel comme un simple cube. Dans notre monde et donc dans nos <strong>Chunks</strong>, chaque voxel est de la même taille et possède sa propre position. Sur une position donnée, un voxel prendra l&rsquo;entièreté de l&rsquo;espace jusqu&rsquo;aux limites de sa positions (donc jusqu&rsquo;aux voxels voisins).</p>
<p>Voilà, donc avec simplement une position, on peut représenter un voxel ! Bon, on aimerait aussi pouvoir donne un style à chaque voxel pour éviter de se retrouver avec des voxels tous identiques. Ici plusieurs possibilités :</p>
<ul>
<li>Stocker dans chaque voxel un <code>Material</code> (Un <code>Material</code> représente souvent un ensemble de couleur définissant comment un objet devra réagir à la lumière).</li>
<li>Stocker un identifiant définissant le type de surface que représente le voxel (Chaque identifiant étant donc relié à un <code>Material</code>).</li>
</ul>
<p>Bien que la première approche permette une totale liberté sur les possibilités de surfaces pour les voxels (et ce même de manière dynamique), sur un terrain nous ne voulons de toute façon pas permettre un nombre infini de type de surfaces.</p>
<p>La seconde approche a l&rsquo;avantage d&rsquo;être <strong>BEAUCOUP</strong> moins coûteuse en place, là ou la première nécessiterais de stocker au moins 3 couleurs et un flottant pour chaque voxels (donc <code>3 * 3 + 1 = 10</code> flottants par voxel), la seconde approche permet de ne stocker que un entier pour chaque voxel.</p>
<p>Donc pour résumer, voici à quoi devrait ressembler une structure <code>Voxel</code> :</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Voxel</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span> <span class="c1">// Position dans le chunk
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">id</span><span class="p">;</span> <span class="c1">// L&#39;identifiant du voxel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>Maintenant, voyons comment nous allons pouvoir stocker nos voxels dans nos <strong>Chunks</strong> !</p>
<h3 id="le-simple-vector">Le simple Vector<a hidden class="anchor" aria-hidden="true" href="#le-simple-vector">#</a></h3>
<p>Bon, on en parle depuis l&rsquo;introduction donc vous avez du le voir venir, mais la première approche, la plus simple mais aussi la plus naïve de toutes 🤪, stockers les voxels de notre <strong>Chunk</strong> dans un <code>vector</code> !</p>
<p>Il nous suffit donc de créer un <code>vector</code> de <code>Voxel</code> :</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Voxel</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span> 
</span></span></code></pre></div><p>Cette approche possède plusieurs problèmes majeurs.
Premièrement, on ne tire aucunement partie de la forme particulière de notre <strong>Chunk</strong> qui est un volume cubique pour les informations de positions.
Mais surtout, vérifier la présence d&rsquo;un voxel sur une position précise au sein d&rsquo;un <strong>Chunk</strong> est extrêmement coûteux car il n&rsquo;y a pas d&rsquo;autres moyens que de parcourir le <code>vector</code> entier et tester les positions de tous les voxels. Cette opération risquant d&rsquo;être très courante dans notre moteur (Calculs de collisions, sélection, occlusion ambiante&hellip;) nous allons éviter cette modélisation.</p>
<h3 id="la-grille">La Grille<a hidden class="anchor" aria-hidden="true" href="#la-grille">#</a></h3>
<p>Comment tirer partie de la forme de notre <strong>Chunk</strong> qui est en fait un volume cubique ? Et bien en stockant nos voxels sous la forme d&rsquo;une grille !</p>
<p>L&rsquo;avantage d&rsquo;une telle structure de données est qu&rsquo;il est possible de savoir la présence ou non d&rsquo;un voxel sur une position dans notre <strong>Chunk</strong> instantanément contrairement au simple <code>vector</code> !</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">array</span><span class="o">&lt;</span><span class="n">array</span><span class="o">&lt;</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">64</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">64</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">64</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
</span></span></code></pre></div><p>ou</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="mi">64</span><span class="p">][</span><span class="mi">64</span><span class="p">][</span><span class="mi">64</span><span class="p">];</span>
</span></span></code></pre></div><p>La structure d&rsquo;une grille permet donc de stocker l&rsquo;information de la position naturellement via les index des donnés dans la grille, permettant ainsi de n&rsquo;avoir à stocker que l&rsquo;identifiants de nos voxel !</p>
<h4 id="index-">Index ?<a hidden class="anchor" aria-hidden="true" href="#index-">#</a></h4>
<p>Pour les personnes qui ne sont pas familières avec ce qu&rsquo;est un &ldquo;index&rdquo;, il s&rsquo;agit simplement du numéro d&rsquo;un élément dans nos données. Par exemple si je créé le tableau suivant :</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">mon_tableau</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
</span></span></code></pre></div><p>Je peux dire que l&rsquo;élément <code>7</code> est à l&rsquo;index <strong>0</strong> et l&rsquo;élément <code>6</code> est à l&rsquo;index <strong>3</strong>. Notez que dans la plus part des langages informatiques (et donc en <strong>C++</strong>), les index commencent à <strong>0</strong>.</p>
<p>Dans notre grille, on peut donc par exemple accéder à l&rsquo;élément en position <code>x = 14</code>, <code>z = 6</code> et <code>z = 61</code> en faisant <code>data[14][6][61]</code>. L&rsquo;accès est donc en temps constant et la vérification de la présence ou non d&rsquo;un voxel sur une certaine position dans nos <strong>Chunks</strong> est quasiment instantané (notez qu&rsquo;on conservera l&rsquo;identifiant de voxel <strong>0</strong> comme représentant le <strong>vide</strong>), ce qui est un énorme avantage par rapport au simple <code>vector</code>.</p>
<p>Malheureusement, ça ne peut pas être aussi simple, il y a deux soucis avec cette représentation :</p>
<ul>
<li><strong>L&rsquo;espace</strong> : Cette représentation nécessite de devoir initialiser l&rsquo;entièreté des voxels possible dans notre <strong>Chunk</strong>, forçant un <strong>Chunk</strong> vide à prendre autant de place en mémoire qu&rsquo;un <strong>Chunk</strong> remplie (même si l&rsquo;espace est vide, ces positions seront occupé par des identifiants <strong>0</strong> représentant donc ce vide).</li>
<li><strong>L&rsquo;accès</strong> : Et là vous allez me dire : &ldquo;Mais je pensais que l&rsquo;accès était justement le point fort des grilles ?&rdquo;. Alors oui&hellip; mais aussi non. En effet, accéder à l&rsquo;information &ldquo;existe-t-il un voxel sur cette position ?&rdquo; est très rapide, mais accéder à la totalité des voxels est plus compliqué. Il faut pour cela parcourir l&rsquo;intégralité de la grille et vérifier tout les éléments qui ne sont pas égale à <strong>0</strong>.</li>
</ul>
<p>On remarquera que ces deux soucis ne sont pas présent avec la représentation dans un simple <code>vector</code>. Particulièrement le second, qui risque de ralentir la creation des données d&rsquo;affichage à envoyer à la carte graphique si on imagine un système de rendu traditionnelle avec donc la creation d&rsquo;une &ldquo;mesh&rdquo; (Pas besoins de s&rsquo;attarder sur ce terme ici, il faut juste noter qu&rsquo;on aimerais simplement pouvoir récupérer tous les voxels existant sans devoir parcourir tout les espaces vide de notre grille).</p>
<h3 id="grille--vector-">Grille + Vector 🥰<a hidden class="anchor" aria-hidden="true" href="#grille--vector-">#</a></h3>
<p>Pour résumer, on aime la grille pour son accès en temps contant à un voxel en fonction de sa position, et on aime le <code>vector</code> pour le parcours de tout les voxels rapide.
Et si on combinais ces deux structures ?</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Voxel</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">posToIndex</span><span class="p">[</span><span class="mi">64</span><span class="p">][</span><span class="mi">64</span><span class="p">][</span><span class="mi">64</span><span class="p">];</span>
</span></span></code></pre></div><p>L&rsquo;idée ici va être d&rsquo;avoir notre grille qui va venir stocker l&rsquo;index des voxels placés et toujours notre <code>vector</code> pour stocker tous nos voxels de façon contiguë !</p>
<p>On peut donc imaginer utiliser ces deux structures comme ceci :</p>
<ul>
<li>
<p>Pour insérer un nouveau voxel :</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">posToIndex</span><span class="p">[</span><span class="n">voxel</span><span class="p">.</span><span class="n">x</span><span class="p">][</span><span class="n">voxel</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">voxel</span><span class="p">.</span><span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">voxel</span><span class="p">);</span> <span class="c1">// push_back permet d&#39;insérer un nouvel élément
</span></span></span></code></pre></div></li>
<li>
<p>Pour récupérer un voxel en fonction de sa position :</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">posToIndex</span><span class="p">[</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">][</span><span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">position</span><span class="p">.</span><span class="n">z</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">Voxel</span> <span class="n">voxel</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
</span></span></code></pre></div></li>
</ul>
<p>Voilà, simple mais efficace ! Bien sûr, on garde toujours l’inconvénient de mémoire de la grille, mais on va dire qu&rsquo;on est prêt à faire ce sacrifice pour bénéficier des avantages de nos deux structures de données !</p>
<p>Ce mode de stockage était celui que j&rsquo;utilisais sur le projet <strong>Mavoxel</strong> au début et était plutôt efficace pour la plus part des opérations dans un système de rendu classique, mais le projet à récemment évolué vers un nouveau mode de rendu, le <strong>Ray-Tracing</strong>, apportant de nouvelles problématiques.</p>
<h2 id="ray-tracing-et-structure-de-données">Ray-Tracing et Structure de données<a hidden class="anchor" aria-hidden="true" href="#ray-tracing-et-structure-de-données">#</a></h2>
<p>Bon, sans rentrer dans trop de détails technique (et puis je compte sûrement écrire un article sur l&rsquo;implémentation du <strong>Ray-Tracing</strong> dans <strong>Mavoxel</strong> qui détaillera un peu plus son fonctionnement), j&rsquo;ai fais le choix de convertir le moteur de rendu en passant d&rsquo;un rendu &ldquo;classique&rdquo; à un rendu en <strong>Ray-Tracing</strong>.</p>
<p>Rapidement, comment rend-t-on une scène avec des techniques de <strong>Ray-Tracing</strong> ? On va se center sur notre caméra et on va tirer un &ldquo;rayon&rdquo; tout droit pour chaque pixel de notre écran.
Ce rayon doit parcourir notre scene jusqu&rsquo;a rencontrer un obstacle ou bien atteindre une distance limite. La couleur qui sera alors affiché à l&rsquo;écran dépendra de l&rsquo;objet touché !</p>
<p>Voici un schéma qui résume assez bien ce fonctionnement :</p>

<p
    
    align="center"
    
>
    <img src="ray_trace_diagram.svg"
        
        
        
        
    >
</p>

<p>Bon, pour afficher notre scene nous devons envoyer notre terrain à notre carte graphique puis tester pour chaque pixel si nous rencontrons un voxel ou non.</p>
<p>Ici, le format grille se prête beaucoup plus à la tâche que le format simple <code>vector</code>. Avec un simple <code>vector</code>, nous devrions tester chaque voxel de notre terrain pour chacun des pixel de notre rendu. Un calcul beaucoup trop complexe bien que les cartes graphiques soit optimiser pour effectuer des calculs en parallèles, on parle ici d&rsquo;une centaine de millier voir de millions de voxels, et donc le même nombre de tests.</p>
<p>Sans trop rentrer dans les détails, en envoyant la grille à notre carte graphique, nous pouvons appliqué un algorithme un peu plus intelligent pour effectuer le <strong>Ray-Tracing</strong> sur notre monde. Nous allons traverser la grille en avançant dans la direction de la caméra, voxel par voxel.</p>
<p>Voici un petit schéma expliquant rapidement l&rsquo;idée derrière l&rsquo;algorithme :</p>

<p
    
    align="center"
    
>
    <img src="grid_ray.png"
        
        
        
        
    >
</p>

<p>Avec un tel algorithme, on est capable d&rsquo;atteindre des performance en <strong>Ray-Tracing</strong> acceptable, avec une distance d&rsquo;affichage d&rsquo;environ 256 voxels. Mais même si c&rsquo;est acceptable, cela reste assez faible. Nous devons trouver un moyen de représenter nos données qui pourrait permettre d&rsquo;accélérer le <strong>Ray-Tracing</strong>.</p>
<p>Maintenant, si je vous disais qu&rsquo;il existe une représentation qui permet une telle prouesse mais qui en plus permet aussi de réduire l&rsquo;espace occupé par les voxels, vous me croiriez ?</p>
<h3 id="sparsed-voxel-octree">Sparsed Voxel Octree<a hidden class="anchor" aria-hidden="true" href="#sparsed-voxel-octree">#</a></h3>
<p>Oula, c&rsquo;est quoi ce nom barbare me direz vous ? Et bien ça les amis, c&rsquo;est une structure de données super ingénieuse, qui va nous permettre de réduire drastiquement nos temps de calculs lors d&rsquo;un <strong>Ray-Tracing</strong> mais aussi de réduire la mémoire occupé par nos voxels !</p>
<p>Un <strong>Sparsed Voxel Octree</strong> (que l&rsquo;on appellera dorénavant SVO si ça ne vous dérange pas 😉) est une forme particulière d&rsquo;<strong>Octree</strong>. Sans rentrer dans les détails, un <strong>Octree</strong> est une structure de données permettant de diviser un espace en plusieurs sous espace, eux même aussi diviser jusqu&rsquo;à ce que ces sous espace soit complètement vide ou complètement plein.</p>
<p>Un <strong>Octree</strong> est donc assez général et peut être utilisé pour représenter l&rsquo;occupation d&rsquo;un espace par différents types d&rsquo;objets. Mais ici nous allons nous intéresser à sa variante, le <strong>SVO</strong>, qui comme son nom l&rsquo;indique sert à représenter l&rsquo;occupation d&rsquo;un espace par des voxels.</p>
<p>L&rsquo;idée derrière cette structure de données est la suivante :</p>
<ul>
<li>On choisit une taille pour notre <strong>SVO</strong> qui doit être une puissance de <strong>2</strong> (Par exemple <code>64</code>).</li>
<li>On divise l&rsquo;espace de notre <strong>SVO</strong> en 8 parts égales, séparé au milieu des 3 axes (donc sur la coordonnée <code>32</code> dans notre exemple).</li>
<li>Pour chacun des sous-espace créé, on vérifie si les voxels qu&rsquo;il englobe sont tous du même type (Comprendre ici qu&rsquo;ils ont tous le même identifiant, 0 étant considéré comme du vide). Si c&rsquo;est le cas, on peut s&rsquo;arrêter ici, sinon on répète l&rsquo;étape <strong>2</strong> (Cette fois-ci sur la coordonnée <code>16</code>, puis <code>8</code>, <code>4</code> et <code>2</code>).</li>
<li>Après toutes ces étapes, on est assuré que chaque sous-espace de notre <strong>SVO</strong> est entièrement composé du même type de voxel ou de vide.</li>
</ul>
<p>Bon, ça fais beaucoup, donc rien de mieux qu&rsquo;un petit schéma pour résumer tout ça !</p>

<p
    
    align="center"
    
>
    <img src="octree.png"
        
        
        
        
    >
</p>

<p>Et un petit schéma pour imager le passage d&rsquo;une grille à un <strong>SVO</strong> :</p>

<p
    
    align="center"
    
>
    <img src="grid_to_svo.png"
        
        
        
        
    >
</p>

<p>Je pense que vous pouvez assez clairement voir en quoi cette représentation permet de gagner de la mémoire, mais par-contre, en quoi va-t-elle nous aider pour notre <strong>Ray-Tracing</strong> ? Et bien, si on reprend notre précédent algorithme qui nous faisais parcourir les voxels de notre grille en suivant la direction de notre caméra, on peut faire la même chose ici mais en sautant directement les portions vide. On peut déjà imaginer une grille qui était totalement vide mais qui prenait quand même <strong>64</strong> itération pour être parcouru par notre algorithme de <strong>Ray-Tracing</strong> sur sa longueur, là où avec notre <strong>SVO</strong> et notre version adapté de notre algorithme, cela ne prendra plus que <strong>4</strong> itérations !</p>
<p>Voici un petit schéma pour mieux visualiser la logique derrière ce nouvel algorithme :</p>

<p
    
    align="center"
    
>
    <img src="octree_ray.png"
        
        
        
        
    >
</p>

<p>Il y a quand même toujours deux inconvénients :</p>
<ul>
<li><strong>Toujours l’accès</strong> : Et oui, comme pour la grille, récupérer la liste complète des voxels présent dans notre <strong>Chunk</strong> sans avoir de <code>vector</code> est une tâche coûteuse ! Mais étant donné que nous allons remplacer notre mode de rendu classique par le rendu en <strong>Ray-Tracing</strong>, nous n&rsquo;aurons plus vraiment besoins de récupérer une telle liste.</li>
<li><strong>Plus lent pour récupérer une position</strong> : Contrairement à la grille qui permettait de récupérer instantanément un voxel en fonction d&rsquo;une position, dans notre <strong>SVO</strong> cet opération est légèrement plus coûteuse, cela reste beaucoup, beaucoup plus rapide qu&rsquo;avec un simple <code>vector</code> et on pourra négliger ce coût, mais il est quand même important de le mentionner.</li>
</ul>
<p>Mais malgré ces deux points, la structure de données <strong>SVO</strong> reste extrêmement intéressante et nous permet d&rsquo;obtenir les meilleurs performances en temps réel avec l&rsquo;algorithme de <strong>Ray-Tracing</strong>, tout en conservant une occupation de la mémoire plus que raisonnable !</p>
<p>Malheureusement et pour votre plus grande tristesse, je n&rsquo;ai pas de démonstration à vous présenter pour conclure cet article 🥺. En effet il est assez difficile montrer l&rsquo;implémentation d&rsquo;une nouvelle structure de données, mais je vais promet que pour le prochain article sur le <strong>Ray-Tracing</strong>, vous pourrez voir à l&rsquo;oeuvre toute la puissance du <strong>SVO</strong> couplé avec un algorithme de <strong>Ray-Tracing</strong> !</p>
<p>Si vous avez une remarque ou des questions, ou si vous êtes intéressé pour parler un peu plus de l&rsquo;implémentation du <strong>SVO</strong>, n&rsquo;hésitez pas à me contacter, vous pouvez retrouver mon email sur mon site personnel en entrant la commande <code>CONTACT</code> !</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://themagnat.github.io/blog/tags/mavoxel/">Mavoxel</a></li>
      <li><a href="https://themagnat.github.io/blog/tags/data-structures/">Data structures</a></li>
      <li><a href="https://themagnat.github.io/blog/tags/ray-tracing/">Ray-Tracing</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://themagnat.github.io/blog/posts/mavoxel/collisions/">
    <span class="title">Suivant »</span>
    <br>
    <span>Mavoxel - Developement d&#39;un système de Collision</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Mavoxel - Représentations en mémoire d&#39;un monde de Voxels on twitter"
        href="https://twitter.com/intent/tweet/?text=Mavoxel%20-%20Repr%c3%a9sentations%20en%20m%c3%a9moire%20d%27un%20monde%20de%20Voxels&amp;url=https%3a%2f%2fthemagnat.github.io%2fblog%2fposts%2fmavoxel%2fdatarepresentation%2f&amp;hashtags=Mavoxel%2cDatastructures%2cRay-Tracing">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Mavoxel - Représentations en mémoire d&#39;un monde de Voxels on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fthemagnat.github.io%2fblog%2fposts%2fmavoxel%2fdatarepresentation%2f&amp;title=Mavoxel%20-%20Repr%c3%a9sentations%20en%20m%c3%a9moire%20d%27un%20monde%20de%20Voxels&amp;summary=Mavoxel%20-%20Repr%c3%a9sentations%20en%20m%c3%a9moire%20d%27un%20monde%20de%20Voxels&amp;source=https%3a%2f%2fthemagnat.github.io%2fblog%2fposts%2fmavoxel%2fdatarepresentation%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Mavoxel - Représentations en mémoire d&#39;un monde de Voxels on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fthemagnat.github.io%2fblog%2fposts%2fmavoxel%2fdatarepresentation%2f&title=Mavoxel%20-%20Repr%c3%a9sentations%20en%20m%c3%a9moire%20d%27un%20monde%20de%20Voxels">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Mavoxel - Représentations en mémoire d&#39;un monde de Voxels on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fthemagnat.github.io%2fblog%2fposts%2fmavoxel%2fdatarepresentation%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Mavoxel - Représentations en mémoire d&#39;un monde de Voxels on whatsapp"
        href="https://api.whatsapp.com/send?text=Mavoxel%20-%20Repr%c3%a9sentations%20en%20m%c3%a9moire%20d%27un%20monde%20de%20Voxels%20-%20https%3a%2f%2fthemagnat.github.io%2fblog%2fposts%2fmavoxel%2fdatarepresentation%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Mavoxel - Représentations en mémoire d&#39;un monde de Voxels on telegram"
        href="https://telegram.me/share/url?text=Mavoxel%20-%20Repr%c3%a9sentations%20en%20m%c3%a9moire%20d%27un%20monde%20de%20Voxels&amp;url=https%3a%2f%2fthemagnat.github.io%2fblog%2fposts%2fmavoxel%2fdatarepresentation%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://themagnat.github.io/blog/">DevBlog de Magnat</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'Copier';

        function copyingDone() {
            copybutton.innerHTML = 'Copié !';
            setTimeout(() => {
                copybutton.innerHTML = 'Copier';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
